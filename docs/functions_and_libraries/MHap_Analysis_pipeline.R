#!/bin/r env

library(argparse)
library(stringr)
library(rmarkdown)
# Parse arguments ----

parser = ArgumentParser()

# PATHs to references and functions

parser$add_argument("-wd", "--wd", 
                    help="Path to input and output files or folders")

parser$add_argument("-fd", "--fd", default = 'null',
                    help="Path to function files")

parser$add_argument("-rd", "--rd", default = 'null',
                    help="Path to reference files")

# Upload of raw data

parser$add_argument("-cigar_paths", "--cigar_paths",  default = 'null',
                    help='Name of the path where one or more outputs of the denoising pipeline are located. The directory structure inside cigar_paths folder shoud be "dada2/run_dada2/"')

parser$add_argument("-cigar_files", "--cigar_files",  default = 'null',
                    help='Name of the folder where one or more cigar files are located. All cigar files must have the folowing name structure: "(\\w+_)?CIGARVariants(_Bfilter_)?(_?w+|\\d+)?.tsv"')

parser$add_argument("-asv_table_files", "--asv_table_files",  default = 'null',
                    help='Name of the folder where one or more ASV Tables are located. All ASV Tables must have the folowing name structure: "(\\w+_)?ASVTables(_?w+|\\d+)?.txt"')

parser$add_argument("-asv2cigar_files", "--asv2cigar_files",  default = 'null',
                    help='Name of the folder where one or more ASV_to_CIGAR tables are located. All ASV_to_CIGAR Tables must have the folowing name structure: "(\\w+_)?ASV_to_CIGAR.out(_?w+|\\d+)?.txt"')

parser$add_argument("-asv_seq_files", "--asv_seq_files",  default = 'null',
                    help='Name of the folder where one or more ASVSeqs.fasta files are located. All ASVSeqs.fasta files must have the folowing name structure: "(\\w+_)?ASVSeqs(_?w+|\\d+)?.fasta"')

parser$add_argument("-zero_read_sample_list", "--zero_read_sample_list",  default = 'null',
                    help='Name of the folder where one or more zeroReadSamples tables are located. All zeroReadSamples tables must have the folowing name structure: "(\\w+_)?zeroReadSamples(_?w+|\\d+)?.txt"')

parser$add_argument("-ampseqj", "--ampseq_jsonfile",  default = 'null',
                    help="name of the ampseq file in json format")

parser$add_argument("-ampseqe", "--ampseq_excelfile",  default = 'null',
                    help="name of the ampseq file in excel format")

parser$add_argument("-ampseqc", "--ampseq_csvfolder",  default = 'null',
                    help="Name of the folder where all the slots of the ampseq object are stored in csv files")

parser$add_argument("-sample_id_pattern", "--sample_id_pattern", default = ".",
                    help="Regular expression the allows to identify samples of interest and remove controls or other undesired samples that we don’t want in further analysis")

parser$add_argument("-markers", "--markers", default = "null",
                    help="Name of the csv. table that contains coordinates of the each marker in the reference genome and the distance in bp between contiguous markers in a chromosome (This information is required for IBD estimation). If this table is not provided the slot in the AmpSeq object will be filled just with the list of the names of markers extracted from the cigar table")

# Paramters to export data and results

parser$add_argument("-o", "--out",
                    help="string that define the prefix to be used for naming all output files and headers in the reports.")

parser$add_argument("-ampseq_export_format", "--ampseq_export_format",  default = 'null',
                    help='String that specify the format to export the filtered and masked ampseq object, options are "xlsx", "csv", and "json"')

# Removing or masking ASVs in the genotype table
parser$add_argument("-min_abd", "--min_abd", default = 'null',
                    help="Integer that define the minimum read depth of trusted alleles. Alleles bellow this threshold will be removed. The default is 10 reads, however, if data was generated by an iSeq100 machine or if the sequencing run was overloaded with samples (high occupancy and low QC30) a lower threshold is recommended.")

parser$add_argument("-min_ratio", "--min_ratio", default = 'null',
                    help="numeric value that define the minimum ratio between the read depth of minor alleles respect to major alleles in heterozygous positions. Minor alleles bellow this threshold will be discarded. (default 0.1) As for the previous parameter, the ratio depends on the quality and depth of the sequencing run.")

parser$add_argument("-off_target_formula", "--off_target_formula", default = "dVSITES_ij>=0.3",
                    help="Formula used to identify and remove off-targget PCR products. By default the parameter density of variant sites of the ASV (or allele i) per amplicon j (dVSTIES_ij) is used, but other metrics can be employed also")

parser$add_argument("-flanking_INDEL_formula", "--flanking_INDEL_formula", default = "flanking_INDEL==TRUE&h_ij>=0.66",
                    help="Formula for masking INDELs in flanking areas of the ASV")

parser$add_argument("-homopolymer_length", "--homopolymer_length", default = 5,
                    help="Minimun number of single nucleotide tandem repeats to define an homopolymer region in an ASV")

parser$add_argument("-SNV_in_homopolymer_formula", "--SNV_in_homopolymer_formula", default = "SNV_in_homopolymer_formula==TRUE&h_ij>=0.66",
                    help="Formula for masking SNVs in homopolymer regions of ASVs")

parser$add_argument("-INDEL_in_homopolymer_formula", "--INDEL_in_homopolymer_formula", default = "INDEL_in_homopolymer_formula==TRUE&h_ij>=0.66",
                    help="Formula for masking INDELs in homopolymer regions of ASVs")

parser$add_argument("-bimera_formula", "--bimera_formula", default = "bimera_formula==TRUE&h_ij>=0.66",
                    help="Formula for removing bimeras")

parser$add_argument("-PCR_errors_formula", "--PCR_errors_formula", default = "h_ij>=0.66&h_ijminor>=0.66&p_ij>=0.05",
                    help="Formula used to define other kinds of PCR errors.")


# Removing samples or loci with low performance

parser$add_argument("-samprate", "--sample_ampl_rate", default = 0.75,
                    help="Min proportion of amplified loci by a sample that is required for the sample to be kept (default 0.75).")

parser$add_argument("-lamprate", "--locus_ampl_rate", default = 0.75,
                    help="Min proportion of amplified samples by a locus that is required for the locus to be kept (default 0.75).")

# Adding metadata

parser$add_argument("-metadata", "--metadata", default = 'null',
                    help="Name of the metadata file in csv format. If not required write null, and a metadata slot will be created in the AmpSeq object, the created metadata table will contain the samples ids (Sample_id), the name of the run plate, the order in the PCR plate and the type of sample (sample of interest or controls).")

parser$add_argument("-join_by", "--join_by", default = 'null',
                    help="string that indicates the variable where Sample ID's are stored. Just if  Sample ID's are not labeled as Sample_id")

parser$add_argument("-Var1", "--Variable1", default = 'null',
                    help="Name of variable in metadata that we want to use to group samples and split the outputs or summary metrics. For some visual representations geographic information is better to be written in Variable1, while temporal information should be in Variable2.")

parser$add_argument("-Var2", "--Variable2", default = 'null',
                    help="Name of variables in metadata that we want to use to group samples and split the outputs or summary metrics. For some visual representations geographic information is better to be written in Variable1, while temporal information should be in Variable2.")

parser$add_argument("-Longitude", "--Longitude", default = 'null',
                    help="Name of variables in the metadata that indicates the geographic coordinates in decimal degrees WGS84 system. These variables are only required visualization of information in maps. The coordinates can be at any geographic level (household, village, district, region, country, etc.), and depending on the geographic level defined by Variable1, all observations in each category will be summarized using their centroid.")

parser$add_argument("-Latitude", "--Latitude", default = 'null',
                    help="Name of variables in the metadata that indicates the geographic coordinates in decimal degrees WGS84 system. These variables are only required visualization of information in maps. The coordinates can be at any geographic level (household, village, district, region, country, etc.), and depending on the geographic level defined by Variable1, all observations in each category will be summarized using their centroid.")

# Filtering desired or undesired populations or samples

parser$add_argument("-var_filter", "--var_filter", default = 'null',
                    help='String used to filter desired categories for further analysis. This argument was created because sometimes we only want to generate the report of a subset of the total number of categories in our dataset (select specific locations or time points). The syntax for this input is as follows: “Variable1_Name;Keep;Category1,Category2,Category3/Varibale2_Name;Remove;Category1,Category2” Where the slatch bar the variables of interest, Varable1_Name and Variable2_Name is the name of the picked variables from the metadata table, “;” separates the name of the variables, the action to be performed (keep or remove, capital or lowercase letters are accepted) and the categories within the variables, and “,” separates the categories within variables. If the name of the categories or the variables contains blank spaces use dots “.” represent them (The requirement of the dot (“.”) is because an error argparse function in R and Python).')

# Reports

parser$add_argument("-PerformanceReport", "--PerformanceReport", default = FALSE,
                    help="Boolean. If this input is true, the filtering step is executed after the generation of the report. This reports includes: 1) A heatmap of the read depth of each marker and each sample, this heatmap is facet based on Variable1. 2)Dot and jitter plots of read depth across different categories (Variable1). 3) Histograms of the amplification rate of the samples and the amplification rate of the loci.")


parser$add_argument("-Drug_Surveillance_Report", "--Drug_Surveillance_Report", default = FALSE,
                    help="Boolean. If this is set to true, other inputs are required, and they are going to be explained in next slides. The output of this reports includes: 1) Report card maps for each desired drug, where the list of drugs is specified by the argument drug. 2) Line plots and stacked bar plots for the different phenotypes for each desired drug. 3) Line plots and stacked bar plots for the different haplotypes for each gene target. 4) Table with the haplotype and phenotype of each sample for each targeted gene.")


parser$add_argument("-Variants_of_Interest_Report", "--Variants_of_Interest_Report", default = FALSE,
                    help="Boolean. This report is similar to the Drug_Surveillance_Report, however it is intended for gene targets whose phenotypes are unknown as in the case of Plasmodium vivax or vaccine candidates.")

parser$add_argument("-ibd", "--ibd_thres", default = 'null',
                    help="Numerical value that set Minimum IBD to define highly related samples. If this parameter is different than null, then two reports are going to be written.")

parser$add_argument("-poly_formula", "--poly_formula", default = "NHetLoci>=1&Fws<1",
                    help='Formula used to define a polyclonal sample. (default: "NHetLoci>=1&Fws<1".')


# Parameters for DSR

parser$add_argument("-gff", "--ref_gff", default = 'null',
                    help="name of .gff file containing coordinates of genomic regions")

parser$add_argument("-fasta", "--ref_fasta", default = 'null',
                    help="name of .fasta file of the genome of reference")

parser$add_argument("-amp_fasta", "--amplicon_fasta", default = 'null',
                    help="name of .fasta file of the inserts of the amplicons on the reference strain")

parser$add_argument("-reference_alleles", "--reference_alleles", default = 'null',
                    help="name of .csv file containing sensitive alleles respect to a drug treatment")

parser$add_argument("-hap_color_palette", "--hap_color_palette", default = 'auto',
                    help="Character indicating how colors will be assigned to haplotypes in drug plots. If 'auto' (defualt), the red scales will be applied based on the presence of mutations associated with resistance, instead if 'random', a random palette will be generated")

parser$add_argument("-gene_names", "--gene_names", default = 'null',
                    help="gene name on the markers csv file")

parser$add_argument("-gene_ids", "--gene_ids", default = 'null',
                    help="gene ids on the .gff file")

parser$add_argument("-drugs", "--drugs", default = 'null',
                    help="Vector which allows to define the drugs that we want to screen and generate plots for the presence of resistant mutations.")

parser$add_argument("-include_all_drug_markers", "--include_all_drug_markers", default = FALSE,
                    help="boolean that allows to incorporate amplicons that were  discarded during the filtering process for having low amplification rate.")

parser$add_argument("-na_var_rm", "--na_var_rm", default = FALSE,
                    help="boolean that removes samples that have incomplete metadata (Variable1 or Variable2 is missing). This is another way to remove controls or samples in the cigar tables that belongs to other project or study sites that we don’t want to include in the final report, however, if there are spelling errors in the sample ids then we won’t be able to detect them.")

parser$add_argument("-na_hap_rm", "--na_hap_rm", default = FALSE,
                    help="boolean that remove samples with incomplete haplotypes from the calculus of the haplotypes frequencies and the plots from the final reports.")


# Parameters for IBD and Conectivity report

## UGER parameters for IBD calculation using task arrays
### Only "nTasks must be defined in the json file, the other two parameters are defined automatically

parser$add_argument("-t", "--nTasks", default = 1,
                    help="Number of Tasks arrays to split the estimation of IBD using tasks arrays in UGER")

parser$add_argument("-tid", "--Task_id", default = 'null',
                    help="Tasks array ID defined by UGER")

parser$add_argument("-ibd_step", "--ibd_step", default = 'null',
                    help="Step of the estimation of IBD, ")

## Other parameters for IBD

parser$add_argument("-pairwise_relatedness_table", "--pairwise_relatedness_table", default = 'null',
                    help="string with the file name of the pairwise_relatedness_table")

parser$add_argument("-nchunks", "--nchunks", default = 500,
                    help="Number of chunks to subdivide the pairwise comparisons to reduce the consumption of RAM memory")

parser$add_argument("-parallel", "--parallel", default = FALSE,
                    help="Boolean to allow parallelization of the estimation of IBD")

parser$add_argument("-ibd_ncol", "--ibd_ncol", default = 4,
                    help="Number of column to use to draw different panels in plots")

parser$add_argument("-pop_levels", "--pop_levels", default = 'null',
                    help="Order in which categories of Variable1 and Variable2 are going to be display in plots")

# Parameters for COI report

parser$add_argument("-poly_quantile", "--poly_quantile", default = 'null',
                    help="Quantile to define polyclonal samples if this parameter is included in poly_formula")

# Defining and checking variables ----

print("starting to parse variables")
args = parser$parse_args()

## PATHs to references and functions----

# Working directory
wd = gsub("/$", "", args$wd)

print(paste0('wd: ', wd))
setwd(wd) 

# Tools or functions directory
fd = gsub("/$", "", args$fd)
print(paste0('fd: ', fd))

# Reference files directory
rd = gsub("/$", "", args$rd)
print(paste0('rd: ', rd))

## Upload of raw data----
# Starting cigar file
cigar_paths = args$cigar_paths
cigar_paths = if(cigar_paths == 'null'){NULL}else{file.path(wd, cigar_paths)}
print(paste0('cigar_paths: ', cigar_paths))

# Starting cigar file
cigar_files = args$cigar_files
cigar_files = if(cigar_files == 'null'){NULL}else{file.path(wd, cigar_files)}
print(paste0('cigar_files: ', cigar_files))

# Starting cigar file
asv_table_files = args$asv_table_files
asv_table_files = if(asv_table_files == 'null'){NULL}else{file.path(wd, asv_table_files)}
print(paste0('asv_table_files: ', cigar_files))

# Starting cigar file
asv2cigar_files = args$asv2cigar_files
asv2cigar_files = if(asv2cigar_files == 'null'){NULL}else{file.path(wd, asv2cigar_files)}
print(paste0('asv2cigar_files: ', asv2cigar_files))

# Starting cigar file
asv_seq_files = args$asv_seq_files
asv_seq_files = if(asv_seq_files == 'null'){NULL}else{file.path(wd, asv_seq_files)}
print(paste0('asv_seq_files: ', asv_seq_files))

# Starting cigar file
zero_read_sample_list = args$zero_read_sample_list
zero_read_sample_list = if(zero_read_sample_list == 'null'){NULL}else{file.path(wd, zero_read_sample_list)}
print(paste0('zero_read_sample_list: ', zero_read_sample_list))


# Starting ampseq file in json format
ampseq_jsonfile = args$ampseq_jsonfile
ampseq_jsonfile = if(ampseq_jsonfile == 'null'){NULL}else{file.path(wd, ampseq_jsonfile)}
print(paste0('ampseq_jsonfile: ', ampseq_jsonfile))

# Starting ampseq file in excel format
ampseq_excelfile = args$ampseq_excelfile
ampseq_excelfile = if(ampseq_excelfile == 'null'){NULL}else{file.path(wd, args$ampseq_excelfile)}
print(paste0('ampseq_excelfile: ', ampseq_excelfile))

# Starting ampseq file in csv format
ampseq_csvfolder = args$ampseq_csvfolder
ampseq_csvfolder = if(ampseq_csvfolder == 'null'){NULL}else{file.path(wd, args$ampseq_csvfolder)}
print(paste0('ampseq_csvfolder: ', ampseq_csvfolder))

# Pattern to differentiate between samples of interest and controls
sample_id_pattern = args$sample_id_pattern
print(paste0('sample_id_pattern: ', sample_id_pattern))

# csv table with markers information
markers = args$markers
markers = if(markers == 'null'){NULL}else{file.path(rd, markers)}
print(paste0('markers: ', markers))

## Parameters to export data and results----

# output pattern
output = args$out
print(paste0('output: ', output))

# format to export the ampseq object
ampseq_export_format = args$ampseq_export_format
ampseq_export_format = if(ampseq_export_format == 'null'){NULL}else{as.character(ampseq_export_format)}

## Removing or masking ASVs in the genotype table----

# Minimum abundance to call an allele
min_abd = as.integer(args$min_abd)
print(paste0('min_abd: ', min_abd))

# Minimum ratio to call minor alleles

min_ratio = as.numeric(args$min_ratio)
print(paste0('min_ratio: ', min_ratio))

# off_target_formula filter
off_target_formula = as.character(args$off_target_formula)
off_target_formula = if(off_target_formula == 'null'){NULL}else{as.character(off_target_formula)}

if(!is.null(off_target_formula)){
  off_target_formula = gsub('"',"",off_target_formula)
  off_target_formula = gsub('&'," & ",off_target_formula, ignore.case = TRUE)
  off_target_formula = gsub('\\|'," \\| ",off_target_formula, ignore.case = TRUE)
  
  if(grepl("\\w>\\d",off_target_formula)){
    patterns = str_extract_all(off_target_formula, "\\w>\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('>',' > ',pattern)
      off_target_formula = gsub(pattern,
                                replacement,
                                off_target_formula, ignore.case = TRUE)
    }
    
  }
  
  if(grepl("\\w<\\d",off_target_formula)){
    patterns = str_extract_all(off_target_formula, "\\w<\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('<',' < ',pattern)
      off_target_formula = gsub(pattern,
                                replacement,
                                off_target_formula, ignore.case = TRUE)
    }
    
  }
  
  off_target_formula = gsub('>=', " >= ", off_target_formula, ignore.case = TRUE)
  off_target_formula = gsub('<=', " <= ", off_target_formula, ignore.case = TRUE)
  off_target_formula = gsub('==', " == ", off_target_formula, ignore.case = TRUE)
  off_target_formula = gsub('!=', " != ", off_target_formula, ignore.case = TRUE)
  
  off_target_formula = gsub('\\+', " \\+ ", off_target_formula, ignore.case = TRUE)
  off_target_formula = gsub('-', " - ", off_target_formula, ignore.case = TRUE)
  off_target_formula = gsub('\\*', " \\* ", off_target_formula, ignore.case = TRUE)
  off_target_formula = gsub('/', " / ", off_target_formula, ignore.case = TRUE)
  
}

print(paste0('off_target_formula: ', off_target_formula))

# flanking_INDEL_formula filter
flanking_INDEL_formula = as.character(args$flanking_INDEL_formula)
flanking_INDEL_formula = if(flanking_INDEL_formula == 'null'){NULL}else{as.character(flanking_INDEL_formula)}

if(!is.null(flanking_INDEL_formula)){
  flanking_INDEL_formula = gsub('"',"",flanking_INDEL_formula)
  
  flanking_INDEL_formula = gsub('&'," & ",flanking_INDEL_formula, ignore.case = TRUE)
  flanking_INDEL_formula = gsub('\\|'," \\| ",flanking_INDEL_formula, ignore.case = TRUE)
  
  if(grepl("\\w>\\d",flanking_INDEL_formula)){
    patterns = str_extract_all(flanking_INDEL_formula, "\\w>\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('>',' > ',pattern)
      flanking_INDEL_formula = gsub(pattern,
                                    replacement,
                                    flanking_INDEL_formula, ignore.case = TRUE)
    }
    
  }
  
  if(grepl("\\w<\\d",flanking_INDEL_formula)){
    patterns = str_extract_all(flanking_INDEL_formula, "\\w<\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('<',' < ',pattern)
      flanking_INDEL_formula = gsub(pattern,
                                    replacement,
                                    flanking_INDEL_formula, ignore.case = TRUE)
    }
    
  }
  
  flanking_INDEL_formula = gsub('>='," >= ",flanking_INDEL_formula, ignore.case = TRUE)
  flanking_INDEL_formula = gsub('<='," <= ",flanking_INDEL_formula, ignore.case = TRUE)
  flanking_INDEL_formula = gsub('=='," == ",flanking_INDEL_formula, ignore.case = TRUE)
  flanking_INDEL_formula = gsub('!='," != ",flanking_INDEL_formula, ignore.case = TRUE)
  
  flanking_INDEL_formula = gsub('\\+'," \\+ ",flanking_INDEL_formula, ignore.case = TRUE)
  flanking_INDEL_formula = gsub('-'," - ",flanking_INDEL_formula, ignore.case = TRUE)
  flanking_INDEL_formula = gsub('\\*'," \\* ",flanking_INDEL_formula, ignore.case = TRUE)
  flanking_INDEL_formula = gsub('/'," / ",flanking_INDEL_formula, ignore.case = TRUE)
}

print(paste0('flanking_INDEL_formula: ', flanking_INDEL_formula))

# homopolymer_length
homopolymer_length = as.integer(args$homopolymer_length)
print(paste0('homopolymer_length: ', homopolymer_length))

# SNV_in_homopolymer_formula filter
SNV_in_homopolymer_formula = as.character(args$SNV_in_homopolymer_formula)
SNV_in_homopolymer_formula = if(SNV_in_homopolymer_formula == 'null'){NULL}else{as.character(SNV_in_homopolymer_formula)}

if(!is.null(SNV_in_homopolymer_formula)){
  SNV_in_homopolymer_formula = gsub('"',"",SNV_in_homopolymer_formula)
  SNV_in_homopolymer_formula = gsub('&'," & ",SNV_in_homopolymer_formula, ignore.case = TRUE)
  SNV_in_homopolymer_formula = gsub('\\|'," \\| ",SNV_in_homopolymer_formula, ignore.case = TRUE)
  
  if(grepl("\\w>\\d",SNV_in_homopolymer_formula)){
    patterns = str_extract_all(SNV_in_homopolymer_formula, "\\w>\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('>',' > ',pattern)
      SNV_in_homopolymer_formula = gsub(pattern,
                                        replacement,
                                        SNV_in_homopolymer_formula, ignore.case = TRUE)
    }
    
  }
  
  if(grepl("\\w<\\d",SNV_in_homopolymer_formula)){
    patterns = str_extract_all(SNV_in_homopolymer_formula, "\\w<\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('<',' < ',pattern)
      SNV_in_homopolymer_formula = gsub(pattern,
                                        replacement,
                                        SNV_in_homopolymer_formula, ignore.case = TRUE)
    }
    
  }
  
  SNV_in_homopolymer_formula = gsub('>='," >= ",SNV_in_homopolymer_formula, ignore.case = TRUE)
  SNV_in_homopolymer_formula = gsub('<='," <= ",SNV_in_homopolymer_formula, ignore.case = TRUE)
  SNV_in_homopolymer_formula = gsub('=='," == ",SNV_in_homopolymer_formula, ignore.case = TRUE)
  SNV_in_homopolymer_formula = gsub('!='," != ",SNV_in_homopolymer_formula, ignore.case = TRUE)
  
  SNV_in_homopolymer_formula = gsub('\\+'," \\+ ",SNV_in_homopolymer_formula, ignore.case = TRUE)
  SNV_in_homopolymer_formula = gsub('-'," - ",SNV_in_homopolymer_formula, ignore.case = TRUE)
  SNV_in_homopolymer_formula = gsub('\\*'," \\* ",SNV_in_homopolymer_formula, ignore.case = TRUE)
  SNV_in_homopolymer_formula = gsub('/'," / ",SNV_in_homopolymer_formula, ignore.case = TRUE)
}

print(paste0('SNV_in_homopolymer_formula: ', SNV_in_homopolymer_formula))

# INDEL_in_homopolymer_formula filter
INDEL_in_homopolymer_formula = as.character(args$INDEL_in_homopolymer_formula)
INDEL_in_homopolymer_formula = if(INDEL_in_homopolymer_formula == 'null'){NULL}else{as.character(INDEL_in_homopolymer_formula)}

if(!is.null(INDEL_in_homopolymer_formula)){
  INDEL_in_homopolymer_formula = gsub('"',"",INDEL_in_homopolymer_formula)
  INDEL_in_homopolymer_formula = gsub('&'," & ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
  INDEL_in_homopolymer_formula = gsub('\\|'," \\| ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
  
  if(grepl("\\w>\\d",INDEL_in_homopolymer_formula)){
    patterns = str_extract_all(INDEL_in_homopolymer_formula, "\\w>\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('>',' > ',pattern)
      INDEL_in_homopolymer_formula = gsub(pattern,
                                          replacement,
                                          INDEL_in_homopolymer_formula, ignore.case = TRUE)
    }
    
  }
  
  if(grepl("\\w<\\d",INDEL_in_homopolymer_formula)){
    patterns = str_extract_all(INDEL_in_homopolymer_formula, "\\w<\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('<',' < ',pattern)
      INDEL_in_homopolymer_formula = gsub(pattern,
                                          replacement,
                                          INDEL_in_homopolymer_formula, ignore.case = TRUE)
    }
    
  }
  
  INDEL_in_homopolymer_formula = gsub('>='," >= ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
  INDEL_in_homopolymer_formula = gsub('<='," <= ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
  INDEL_in_homopolymer_formula = gsub('=='," == ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
  INDEL_in_homopolymer_formula = gsub('!='," != ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
  
  INDEL_in_homopolymer_formula = gsub('\\+'," \\+ ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
  INDEL_in_homopolymer_formula = gsub('-'," - ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
  INDEL_in_homopolymer_formula = gsub('\\*'," \\* ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
  INDEL_in_homopolymer_formula = gsub('/'," / ",INDEL_in_homopolymer_formula, ignore.case = TRUE)
}

print(paste0('INDEL_in_homopolymer_formula: ', INDEL_in_homopolymer_formula))


# bimera_formula filter
bimera_formula = as.character(args$bimera_formula)
bimera_formula = if(bimera_formula == 'null'){NULL}else{as.character(bimera_formula)}

if(!is.null(bimera_formula)){
  bimera_formula = gsub('"',"",bimera_formula)
  bimera_formula = gsub('&'," & ",bimera_formula, ignore.case = TRUE)
  bimera_formula = gsub('\\|'," \\| ",bimera_formula, ignore.case = TRUE)
  
  if(grepl("\\w>\\d",bimera_formula)){
    patterns = str_extract_all(bimera_formula, "\\w>\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('>',' > ',pattern)
      bimera_formula = gsub(pattern,
                            replacement,
                            bimera_formula, ignore.case = TRUE)
    }
    
  }
  
  if(grepl("\\w<\\d",bimera_formula)){
    patterns = str_extract_all(bimera_formula, "\\w<\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('<',' < ',pattern)
      bimera_formula = gsub(pattern,
                            replacement,
                            bimera_formula, ignore.case = TRUE)
    }
    
  }
  
  bimera_formula = gsub('>='," >= ", bimera_formula, ignore.case = TRUE)
  bimera_formula = gsub('<='," <= ", bimera_formula, ignore.case = TRUE)
  bimera_formula = gsub('=='," == ", bimera_formula, ignore.case = TRUE)
  bimera_formula = gsub('!='," != ", bimera_formula, ignore.case = TRUE)
  
  bimera_formula = gsub('\\+'," \\+ ", bimera_formula, ignore.case = TRUE)
  bimera_formula = gsub('-'," - ", bimera_formula, ignore.case = TRUE)
  bimera_formula = gsub('\\*'," \\* ", bimera_formula, ignore.case = TRUE)
  bimera_formula = gsub('/'," / ", bimera_formula, ignore.case = TRUE)
}

print(paste0('bimera_formula: ', bimera_formula))

# PCR_errors_formula filter
PCR_errors_formula = as.character(args$PCR_errors_formula)
PCR_errors_formula = if(PCR_errors_formula == 'null'){NULL}else{as.character(PCR_errors_formula)}

if(!is.null(PCR_errors_formula)){
  PCR_errors_formula = gsub('"',"",PCR_errors_formula)
  PCR_errors_formula = gsub('&'," & ",PCR_errors_formula, ignore.case = TRUE)
  PCR_errors_formula = gsub('\\|'," \\| ",PCR_errors_formula, ignore.case = TRUE)
  
  if(grepl("\\w>\\d",PCR_errors_formula)){
    patterns = str_extract_all(PCR_errors_formula, "\\w>\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('>',' > ',pattern)
      PCR_errors_formula = gsub(pattern,
                                replacement,
                                PCR_errors_formula, ignore.case = TRUE)
    }
    
  }
  
  if(grepl("\\w<\\d",PCR_errors_formula)){
    patterns = str_extract_all(PCR_errors_formula, "\\w<\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('<',' < ',pattern)
      PCR_errors_formula = gsub(pattern,
                                replacement,
                                PCR_errors_formula, ignore.case = TRUE)
    }
    
  }
  
  PCR_errors_formula = gsub('>='," >= ", PCR_errors_formula, ignore.case = TRUE)
  PCR_errors_formula = gsub('<='," <= ", PCR_errors_formula, ignore.case = TRUE)
  PCR_errors_formula = gsub('=='," == ", PCR_errors_formula, ignore.case = TRUE)
  PCR_errors_formula = gsub('!='," != ", PCR_errors_formula, ignore.case = TRUE)
  
  PCR_errors_formula = gsub('\\+'," \\+ ", PCR_errors_formula, ignore.case = TRUE)
  PCR_errors_formula = gsub('-'," - ", PCR_errors_formula, ignore.case = TRUE)
  PCR_errors_formula = gsub('\\*'," \\* ", PCR_errors_formula, ignore.case = TRUE)
  PCR_errors_formula = gsub('/'," / ", PCR_errors_formula, ignore.case = TRUE)
}

print(paste0('PCR_errors_formula: ', PCR_errors_formula))

## Removing samples or loci with low performance----

# sample_ampl_rate
sample_ampl_rate = as.numeric(args$sample_ampl_rate)
print(paste0('sample_ampl_rate: ', sample_ampl_rate))

# locus_ampl_rate
locus_ampl_rate  = as.numeric(args$locus_ampl_rate)
print(paste0('locus_ampl_rate: ', locus_ampl_rate))

## Adding metadata----

# metadata
metadata_file = as.character(args$metadata)
metadata_file = if(metadata_file == 'null'){NULL}else{file.path(wd, metadata_file)}
print(paste0('metadata: ', metadata_file))

# join metadata by
join_by = as.character(args$join_by)
join_by = if(join_by == 'null'){NULL}else{join_by}
print(paste0('join_by: ', join_by))

# pop
Variable1 = args$Variable1
Variable1 = if(Variable1 == 'null'){NULL}else{Variable1}
print(paste0('Variable1: ', Variable1))

# temporal_population
Variable2 = args$Variable2
Variable2 = if(Variable2 == 'null'){NULL}else{Variable2}
print(paste0('Variable2: ', Variable2))

Longitude = args$Longitude
Longitude = if(Longitude == 'null'){NULL}else{Longitude}
print(paste0('Longitude: ', Longitude))

Latitude = args$Latitude
Latitude = if(Latitude == 'null'){NULL}else{Latitude}
print(paste0('Latitude: ', Latitude))

## Filtering desired or undesired populations or samples----

var_filter  = args$var_filter
if(var_filter == 'null'){
  var_filter = NULL
}else{
  var_filter = gsub('\\.', ' ', var_filter)
  var_filter = strsplit(var_filter, '/')[[1]]
}

print('var_filter: ')
print(var_filter)

## Reports----

# Performance Report
PerformanceReport = as.logical(args$PerformanceReport)
print(paste0('PerformanceReport: ', PerformanceReport))

# Drug surveillance report
Drug_Surveillance_Report = as.logical(args$Drug_Surveillance_Report)
print(paste0('Drug_Surveillance_Report: ', Drug_Surveillance_Report))

# Variants of interest report (in development)
Variants_of_Interest_Report = as.logical(args$Variants_of_Interest_Report)
print(paste0('Variants_of_Interest_Report: ', Variants_of_Interest_Report))

# Reports of IBD and Connectivity and IBD and transmission
ibd_thres = args$ibd_thres
ibd_thres = if(ibd_thres == 'null'){NULL}else{as.numeric(ibd_thres)}
print(paste0('ibd_thres: ', ibd_thres))

# Report for complexity of infection

# poly_formula filter
poly_formula = as.character(args$poly_formula)
poly_formula = if(poly_formula == 'null'){NULL}else{as.character(poly_formula)}

if(!is.null(poly_formula)){

  poly_formula = gsub('"',"",poly_formula)
  poly_formula = gsub('&'," & ",poly_formula, ignore.case = TRUE)
  poly_formula = gsub('\\|'," \\| ",poly_formula, ignore.case = TRUE)
  
  if(grepl("\\w>\\d",poly_formula)){
    patterns = str_extract_all(poly_formula, "\\w>\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('>',' > ',pattern)
      poly_formula = gsub(pattern,
                          replacement,
                          poly_formula, ignore.case = TRUE)
    }
    
  }
  
  if(grepl("\\w<\\d",poly_formula)){
    patterns = str_extract_all(poly_formula, "\\w<\\d")[[1]]
    
    for(pattern in patterns){
      
      replacement = gsub('<',' < ',pattern)
      poly_formula = gsub(pattern,
                          replacement,
                          poly_formula, ignore.case = TRUE)
    }
    
  }
  
  poly_formula = gsub('>='," >= ", poly_formula, ignore.case = TRUE)
  poly_formula = gsub('<='," <= ", poly_formula, ignore.case = TRUE)
  poly_formula = gsub('=='," == ", poly_formula, ignore.case = TRUE)
  poly_formula = gsub('!='," != ", poly_formula, ignore.case = TRUE)
  
  poly_formula = gsub('\\+'," \\+ ", poly_formula, ignore.case = TRUE)
  poly_formula = gsub('-'," - ", poly_formula, ignore.case = TRUE)
  poly_formula = gsub('\\*'," \\* ", poly_formula, ignore.case = TRUE)
  poly_formula = gsub('/'," / ", poly_formula, ignore.case = TRUE)
}

print(paste0('poly_formula: ', poly_formula))

### Parameters for DSR----

# Reference gff and fasta files, require to translate DNA cigar formats to aminoacid sequences

ref_gff = args$ref_gff
ref_gff = if(ref_gff == 'null'){NULL}else{file.path(rd, ref_gff)}
print(paste0('ref_gff: ', ref_gff))

ref_fasta = args$ref_fasta
ref_fasta = if(ref_fasta == 'null'){NULL}else{file.path(rd, ref_fasta)}
print(paste0('ref_fasta: ', ref_fasta))

amplicon_fasta = args$amplicon_fasta
amplicon_fasta = if(amplicon_fasta == 'null'){NULL}else{file.path(rd, amplicon_fasta)}
print(paste0('amplicon_fasta: ', amplicon_fasta))

reference_alleles = args$reference_alleles
reference_alleles = if(reference_alleles == 'null'){NULL}else{file.path(rd, reference_alleles)}
print(paste0('reference_alleles: ', reference_alleles))

hap_color_palette = args$hap_color_palette
print(paste0('hap_color_palette: ', hap_color_palette))

# gene_names
gene_names = args$gene_names
if(gene_names == 'null'){
  gene_names = NULL
}else{
  gene_names = strsplit(gene_names, ',')[[1]]
}
print('gene_names:')
print(gene_names)

# gene_ids
gene_ids = args$gene_ids
if(gene_ids == 'null'){
  gene_ids = NULL
}else{
  gene_ids = strsplit(gene_ids, ',')[[1]]
}
print('gene_ids:')
print(gene_ids)

drugs = args$drugs
if(drugs == 'null'){
  drugs = NULL
}else{
  drugs = strsplit(drugs, ',')[[1]]
}
print('drugs: ')
print(drugs)

include_all_drug_markers = as.logical(args$include_all_drug_markers)
print(paste0('include_all_drug_markers: ', include_all_drug_markers))

na_var_rm = as.logical(args$na_var_rm)
print(paste0('na_var_rm: ', na_var_rm))
      
na_hap_rm = as.logical(args$na_hap_rm)
print(paste0('na_hap_rm: ', na_hap_rm))


### Parameters for IBD and Conectivity report----

#### Parameters for UGER----
# nTasks
nTasks = as.integer(args$nTasks)
print(paste0('nTasks: ', nTasks))

# Task_id
Task_id = as.integer(args$Task_id)
print(paste0('Task_id: ', Task_id))

# ibd_step
ibd_step = as.character(args$ibd_step)
print(paste0('ibd_step: ', ibd_step))

#### Other IBD parameters----

# pairwise_relatedness_table
pairwise_relatedness_table = as.character(args$pairwise_relatedness_table)
pairwise_relatedness_table = if(pairwise_relatedness_table == 'null'){NULL}else{file.path(wd, pairwise_relatedness_table)}
print(paste0('pairwise_relatedness_table: ', pairwise_relatedness_table))

# parallel
parallel = as.logical(args$parallel)
print(paste0('parallel: ', parallel))

# nchunks
nchunks = as.integer(args$nchunks)
print(paste0('nchunks: ', nchunks))

# ibd_ncol
ibd_ncol = as.integer(args$ibd_ncol)
print(paste0('ibd_ncol: ', ibd_ncol))

# pop_levels
pop_levels = as.integer(args$pop_levels)
print(paste0('pop_levels: ', pop_levels))

### Parameters for COI report----
# poly_quantile
poly_quantile = args$poly_quantile
poly_quantile = if(poly_quantile == 'null'){NULL}else{as.numeric(poly_quantile)}
print(paste0('poly_quantile: ', poly_quantile))


# The next five lines are needed for UGER
# if(file.exists(file.path(wd, paste0(output, '.xlsx')))){
#   cigar_paths = NULL
#   cigar_files = NULL
#   ampseq_excelfile = file.path(wd, paste0(output, '.xlsx'))
# }

print("All variables checked")

# Check packages and functions----

print("Loading libraies and functions")
source(file.path(fd,'amplseq_required_libraries.R'))
source(file.path(fd,'amplseq_functions.R'))

# Defining a random color palette for all plots with multiple categorical variables----

qual_col_pals = brewer.pal.info[brewer.pal.info$category == 'qual',]
col_vector = unlist(mapply(brewer.pal, qual_col_pals$maxcolors, rownames(qual_col_pals)))

# Upload Cigar object and convert to ampseq object----

print("starting to upload genotypic data")

if(!is.null(cigar_paths)|!is.null(cigar_files)){
  if(!is.null(cigar_paths)){
    
    print("Uploading genotipic data in cigar format from multiple paths")
    cigar_object = read_cigar_tables(paths = cigar_paths, sample_id_pattern = sample_id_pattern)
  }else if(!is.null(cigar_files)){
    
    if(as.logical(file.info(cigar_files)['isdir'])){
      print("Uploading genotipic data in cigar format from multiple csv files from a single path")
      list_of_cigar_files = file.path(cigar_files,list.files(cigar_files))
      list_of_asv_tables = file.path(asv_table_files,list.files(asv_table_files))
      list_of_asv2cigars = file.path(asv2cigar_files,list.files(asv2cigar_files))
      list_of_asv_seqs = file.path(asv_seq_files,list.files(asv_seq_files))
      list_of_zero_read_samples = file.path(zero_read_sample_list,list.files(zero_read_sample_list))
      
      cigar_object = read_cigar_tables(cigar_files = list_of_cigar_files, 
                                       asv_table_files = list_of_asv_tables, 
                                       asv2cigar_files = list_of_asv2cigars,
                                       asv_seq_files = list_of_asv_seqs, 
                                       zero_read_sample_list = list_of_zero_read_samples,
                                       sample_id_pattern = sample_id_pattern)
      
    }else{
      print("Uploading genotipic data in cigar format from a single file")
      cigar_object = read_cigar_tables(files = cigar_files, sample_id_pattern = sample_id_pattern)
    }
  }
  
  markers = read.csv(markers)
  
  if(PerformanceReport){
    ampseq_object_abd1 = cigar2ampseq(cigar_object, markers = markers, min_abd = 1, min_ratio = min_ratio, remove_controls = F)
    ampseq_object = cigar2ampseq(cigar_object, markers = markers, min_abd = min_abd, min_ratio = min_ratio, remove_controls = F)
 
  }else{
    ampseq_object = cigar2ampseq(cigar_object, markers = markers, min_abd = min_abd, min_ratio = min_ratio, remove_controls = T)
  }
  
  }else if(!is.null(ampseq_jsonfile)){
    print("Uploading genotipic data in ampseq format from json file")
  # In development
  
  }else if(!is.null(ampseq_excelfile)){
    print("Uploading genotipic data in ampseq format from excel file")
  ampseq_object = read_ampseq(file = ampseq_excelfile, format = 'excel')
  
  
  # add discarded samples
  if(sample_ampl_rate != 0 | locus_ampl_rate != 0){
    
    ampseq_object@gt = rbind(ampseq_object@gt,
                             ampseq_object@discarded_samples$gt)
    
    ampseq_object@metadata = rbind(ampseq_object@metadata,
                                   ampseq_object@discarded_samples$metadata)
    
    ampseq_object@discarded_samples = NULL
    
    # add discarded loci
    
    ampseq_object@markers = rbind(ampseq_object@markers,
                                  ampseq_object@discarded_loci$markers)
    
    ampseq_object@markers %<>% arrange(chromosome, start)
    
    # update distance
    
    ampseq_object@markers[["distance"]] = Inf
    
    for(chromosome in levels(as.factor(ampseq_object@markers[["chromosome"]]))){
      for(amplicon in 1:(nrow(ampseq_object@markers[ampseq_object@markers[["chromosome"]] == chromosome,])-1)){
        ampseq_object@markers[ampseq_object@markers[["chromosome"]] == chromosome,][amplicon, "distance"] = 
          ampseq_object@markers[ampseq_object@markers[["chromosome"]] == chromosome,][amplicon + 1, "pos"] - ampseq_object@markers[ampseq_object@markers[["chromosome"]] == chromosome,][amplicon, "pos"]
      }
    }
    
    ampseq_object@gt = ampseq_object@gt[rownames(ampseq_object@discarded_loci$gt),]
    
    ampseq_object@gt = cbind(ampseq_object@gt,
                             ampseq_object@discarded_loci$gt)
    
    ampseq_object@gt = ampseq_object@gt[,ampseq_object@markers$amplicon]
    
    ampseq_object@metadata = ampseq_object@metadata[rownames(ampseq_object@gt),]
    
    ampseq_object@loci_performance = NULL
    
    ampseq_object@discarded_loci = NULL
    
  }
  
  if(PerformanceReport){
    
    # add controls genotypes
    
    controls_gt = matrix(NA,
                         nrow = nrow(ampseq_object@controls$gt),
                         ncol = ncol(ampseq_object@gt),
                         dimnames = list(
                           rownames(ampseq_object@controls$gt),
                           colnames(ampseq_object@gt)
                         ))
    
    for(mhap in colnames(controls_gt)){
      if(mhap %in% colnames(ampseq_object@controls$gt)){
        controls_gt[,mhap] = ampseq_object@controls$gt[,mhap]
      }
    }
    
    ampseq_object@gt = rbind(ampseq_object@gt,
                             controls_gt)
    
    # add controls metadata
    
    controls_metadata = matrix(NA,
                               nrow = nrow(ampseq_object@controls$metadata),
                               ncol = ncol(ampseq_object@metadata),
                               dimnames = list(
                                 rownames(ampseq_object@controls$metadata),
                                 colnames(ampseq_object@metadata)
                               ))
    
    for(variable in colnames(controls_metadata)){
      if(variable %in% colnames(ampseq_object@controls$metadata)){
        controls_metadata[,variable] = ampseq_object@controls$metadata[,variable]
      }
    }
    
    ampseq_object@metadata = rbind(ampseq_object@metadata,
                                   controls_metadata)
    
    
    ampseq_object_abd1 = ampseq_object
    
  }
  
  }else if(!is.null(ampseq_csvfolder)){
    print("Uploading genotipic data in ampseq format from excel file")
    ampseq_object = read_ampseq(file = ampseq_csvfolder, format = 'csv')
    
    
    # add discarded samples
    if(sample_ampl_rate != 0 | locus_ampl_rate != 0){
      
      ampseq_object@gt = rbind(ampseq_object@gt,
                               ampseq_object@discarded_samples$gt)
      
      ampseq_object@metadata = rbind(ampseq_object@metadata,
                                     ampseq_object@discarded_samples$metadata)
      
      ampseq_object@discarded_samples = NULL
      
      # add discarded loci
      
      ampseq_object@markers = rbind(ampseq_object@markers,
                                    ampseq_object@discarded_loci$markers)
      
      ampseq_object@markers %<>% arrange(chromosome, start)
      
      # update distance
      
      ampseq_object@markers[["distance"]] = Inf
      
      for(chromosome in levels(as.factor(ampseq_object@markers[["chromosome"]]))){
        for(amplicon in 1:(nrow(ampseq_object@markers[ampseq_object@markers[["chromosome"]] == chromosome,])-1)){
          ampseq_object@markers[ampseq_object@markers[["chromosome"]] == chromosome,][amplicon, "distance"] = 
            ampseq_object@markers[ampseq_object@markers[["chromosome"]] == chromosome,][amplicon + 1, "pos"] - ampseq_object@markers[ampseq_object@markers[["chromosome"]] == chromosome,][amplicon, "pos"]
        }
      }
      
      ampseq_object@gt = ampseq_object@gt[rownames(ampseq_object@discarded_loci$gt),]
      
      ampseq_object@gt = cbind(ampseq_object@gt,
                               ampseq_object@discarded_loci$gt)
      
      ampseq_object@gt = ampseq_object@gt[,ampseq_object@markers$amplicon]
      
      ampseq_object@metadata = ampseq_object@metadata[rownames(ampseq_object@gt),]
      
      ampseq_object@loci_performance = NULL
      
      ampseq_object@discarded_loci = NULL
      
    }
    
    if(PerformanceReport){
      
      # add controls genotypes
      
      controls_gt = matrix(NA,
                           nrow = nrow(ampseq_object@controls$gt),
                           ncol = ncol(ampseq_object@gt),
                           dimnames = list(
                             rownames(ampseq_object@controls$gt),
                             colnames(ampseq_object@gt)
                           ))
      
      for(mhap in colnames(controls_gt)){
        if(mhap %in% colnames(ampseq_object@controls$gt)){
          controls_gt[,mhap] = ampseq_object@controls$gt[,mhap]
        }
      }
      
      ampseq_object@gt = rbind(ampseq_object@gt,
                               controls_gt)
      
      # add controls metadata
      
      controls_metadata = matrix(NA,
                                 nrow = nrow(ampseq_object@controls$metadata),
                                 ncol = ncol(ampseq_object@metadata),
                                 dimnames = list(
                                   rownames(ampseq_object@controls$metadata),
                                   colnames(ampseq_object@metadata)
                                 ))
      
      for(variable in colnames(controls_metadata)){
        if(variable %in% colnames(ampseq_object@controls$metadata)){
          controls_metadata[,variable] = ampseq_object@controls$metadata[,variable]
        }
      }
      
      ampseq_object@metadata = rbind(ampseq_object@metadata,
                                     controls_metadata)
      
      
      ampseq_object_abd1 = ampseq_object
      
    }
    
  }



# Cleaning, filtering and adding metadata to the  ampseq_object----

if(PerformanceReport){
  
  # add metadata 
  
  if(!is.null(metadata_file)){
    # Upload metadata from an external source
    external_metadata = read.csv(metadata_file)
    
    # Check duplicate samples
    
    if(sum(duplicated(external_metadata$Sample_id)) > 0){
      
      print(paste0('There are ', sum(duplicated(external_metadata$Sample_id)), ' duplicated Ids that are going to be removed'))
      external_metadata %<>% filter(!duplicated(external_metadata$Sample_id))
      
    }
    
    
      shared_variables = names(ampseq_object_abd1@metadata)[names(ampseq_object_abd1@metadata) %in% names(external_metadata)]
      shared_variables = shared_variables[!(shared_variables %in% c('Sample_id', join_by))]

      if(length(shared_variables) > 0){
        print(paste0('The following variables will be overwritten: ', paste(shared_variables, collapse = ', ')))

        for(variable in shared_variables){

          ampseq_object_abd1@metadata[[variable]] = NULL

        }

      }

    print("Adding metadata to ampseq object")
      # Merge the external metadata with our ampseq_object
    ampseq_object_abd1@metadata = left_join(ampseq_object_abd1@metadata,
                                                external_metadata,
                                                  by = join_by)
    }
    
    
  
  ## Sample performance by different coverage----
  ### Overall sample performance by different coverage----
  
  ReadDepth_coverage = get_ReadDepth_coverage(ampseq_object_abd1, variable = NULL)
  
  sample_performance = ReadDepth_coverage$plot_read_depth_heatmap$data %>%
    mutate(Read_depth = case_when(
      is.na(Read_depth) ~ 0,
      !is.na(Read_depth) ~ Read_depth
    )) %>%
    summarise(amplified_amplicons1 = sum(Read_depth >= 1)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons5 = sum(Read_depth >= 5)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons10 = sum(Read_depth >= 10)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons20 = sum(Read_depth >= 20)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons50 = sum(Read_depth >= 50)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons100 = sum(Read_depth >= 100)/nrow(ampseq_object_abd1@markers),
              .by = Sample_id) %>%
    pivot_longer(cols = starts_with('amplified_amplicons'), values_to = 'AmpRate', names_to = 'Threshold') %>%
    mutate(Threshold = as.integer(gsub('amplified_amplicons', '', Threshold)))
  
  if(!(min_abd %in% c(1,5,10,20,50,100))){
    
    sample_performance = rbind(sample_performance,
                               ReadDepth_coverage$plot_read_depth_heatmap$data %>%
                                 mutate(Read_depth = case_when(
                                   is.na(Read_depth) ~ 0,
                                   !is.na(Read_depth) ~ Read_depth
                                 )) %>%
                                 summarise(AmpRate = sum(Read_depth >= min_abd)/nrow(ampseq_object_abd1@markers),
                                           .by = Sample_id) %>%
                                 mutate(Threshold = min_abd) %>%
                                 select(Sample_id, Threshold, AmpRate))
    
  }
  
  plot_precentage_of_samples_over_min_abd = sample_performance %>%
    summarise(AmpRate5 = round(100*sum(AmpRate >= .05)/n(), 1),
              AmpRate10 = round(100*sum(AmpRate >= .10)/n(), 1),
              AmpRate15 = round(100*sum(AmpRate >= .15)/n(), 1),
              AmpRate20 = round(100*sum(AmpRate >= .20)/n(), 1),
              AmpRate25 = round(100*sum(AmpRate >= .25)/n(), 1),
              AmpRate30 = round(100*sum(AmpRate >= .30)/n(), 1),
              AmpRate35 = round(100*sum(AmpRate >= .35)/n(), 1),
              AmpRate40 = round(100*sum(AmpRate >= .40)/n(), 1),
              AmpRate45 = round(100*sum(AmpRate >= .45)/n(), 1),
              AmpRate50 = round(100*sum(AmpRate >= .50)/n(), 1),
              AmpRate55 = round(100*sum(AmpRate >= .55)/n(), 1),
              AmpRate60 = round(100*sum(AmpRate >= .60)/n(), 1),
              AmpRate65 = round(100*sum(AmpRate >= .65)/n(), 1),
              AmpRate70 = round(100*sum(AmpRate >= .70)/n(), 1),
              AmpRate75 = round(100*sum(AmpRate >= .75)/n(), 1),
              AmpRate80 = round(100*sum(AmpRate >= .80)/n(), 1),
              AmpRate85 = round(100*sum(AmpRate >= .85)/n(), 1),
              AmpRate90 = round(100*sum(AmpRate >= .90)/n(), 1),
              AmpRate95 = round(100*sum(AmpRate >= .95)/n(), 1),
              AmpRate100 = round(100*sum(AmpRate >= 1)/n(), 1),
              .by = c(Threshold)
    ) %>%
    pivot_longer(cols = paste0('AmpRate', seq(5, 100, 5)),
                 values_to = 'Percentage',
                 names_to = 'AmpRate') %>%
    mutate(AmpRate = as.numeric(gsub('AmpRate','', AmpRate)))%>%
    ggplot(aes(x = AmpRate, y = Percentage, color = as.factor(Threshold), group = as.factor(Threshold))) +
    geom_line() +
    geom_vline(xintercept = 100*sample_ampl_rate, linetype = 2) +
    theme_bw() +
    labs(x = '% of amplified loci (amplification rate)', y = '% of Samples', color = 'Min Coverage')
  
  ### Overall sample performance by different coverage per Run----
  
  ReadDepth_coverage = get_ReadDepth_coverage(ampseq_object_abd1, variable = 'Run')
  
  sample_performance = ReadDepth_coverage$plot_read_depth_heatmap$data %>%
    mutate(Read_depth = case_when(
      is.na(Read_depth) ~ 0,
      !is.na(Read_depth) ~ Read_depth
    )) %>%
    summarise(amplified_amplicons1 = sum(Read_depth >= 1)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons5 = sum(Read_depth >= 5)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons10 = sum(Read_depth >= 10)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons20 = sum(Read_depth >= 20)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons50 = sum(Read_depth >= 50)/nrow(ampseq_object_abd1@markers),
              amplified_amplicons100 = sum(Read_depth >= 100)/nrow(ampseq_object_abd1@markers),
              Run = unique(var),
              .by = Sample_id) %>%
    pivot_longer(cols = starts_with('amplified_amplicons'), values_to = 'AmpRate', names_to = 'Threshold') %>%
    mutate(Threshold = as.integer(gsub('amplified_amplicons', '', Threshold)))
  
  if(!(min_abd %in% c(1,5,10,20,50,100))){
    
    sample_performance = rbind(sample_performance,
                               ReadDepth_coverage$plot_read_depth_heatmap$data %>%
                                 mutate(Read_depth = case_when(
                                   is.na(Read_depth) ~ 0,
                                   !is.na(Read_depth) ~ Read_depth
                                 )) %>%
                                 summarise(AmpRate = sum(Read_depth >= min_abd)/nrow(ampseq_object_abd1@markers),
                                           Run = unique(var),
                                           .by = Sample_id) %>%
                                 mutate(Threshold = min_abd) %>%
                                 select(Sample_id, Run, Threshold, AmpRate))
    
  }
  
  plot_precentage_of_samples_over_min_abd_byRun = sample_performance %>%
    summarise(AmpRate5 = round(100*sum(AmpRate >= .05)/n(), 1),
              AmpRate10 = round(100*sum(AmpRate >= .10)/n(), 1),
              AmpRate15 = round(100*sum(AmpRate >= .15)/n(), 1),
              AmpRate20 = round(100*sum(AmpRate >= .20)/n(), 1),
              AmpRate25 = round(100*sum(AmpRate >= .25)/n(), 1),
              AmpRate30 = round(100*sum(AmpRate >= .30)/n(), 1),
              AmpRate35 = round(100*sum(AmpRate >= .35)/n(), 1),
              AmpRate40 = round(100*sum(AmpRate >= .40)/n(), 1),
              AmpRate45 = round(100*sum(AmpRate >= .45)/n(), 1),
              AmpRate50 = round(100*sum(AmpRate >= .50)/n(), 1),
              AmpRate55 = round(100*sum(AmpRate >= .55)/n(), 1),
              AmpRate60 = round(100*sum(AmpRate >= .60)/n(), 1),
              AmpRate65 = round(100*sum(AmpRate >= .65)/n(), 1),
              AmpRate70 = round(100*sum(AmpRate >= .70)/n(), 1),
              AmpRate75 = round(100*sum(AmpRate >= .75)/n(), 1),
              AmpRate80 = round(100*sum(AmpRate >= .80)/n(), 1),
              AmpRate85 = round(100*sum(AmpRate >= .85)/n(), 1),
              AmpRate90 = round(100*sum(AmpRate >= .90)/n(), 1),
              AmpRate95 = round(100*sum(AmpRate >= .95)/n(), 1),
              AmpRate100 = round(100*sum(AmpRate >= 1)/n(), 1),
              .by = c(Threshold, Run)
    ) %>%
    pivot_longer(cols = paste0('AmpRate', seq(5, 100, 5)),
                 values_to = 'Percentage',
                 names_to = 'AmpRate') %>%
    mutate(AmpRate = as.numeric(gsub('AmpRate','', AmpRate)))%>%
    ggplot(aes(x = AmpRate, y = Percentage, color = as.factor(Threshold), group = as.factor(Threshold))) +
    geom_line() +
    geom_vline(xintercept = 100*sample_ampl_rate, linetype = 2) +
    facet_wrap(Run~., ncol = 3)+
    theme_bw() +
    labs(x = '% of amplified loci (amplification rate)', y = '% of Samples', color = 'Min Coverage')
  
  
  ### Overall sample performance by different coverage per Variable1----
  
  if(!is.null(Variable1)){
    
    ReadDepth_coverage = get_ReadDepth_coverage(ampseq_object_abd1, variable = Variable1)
    
    sample_performance = ReadDepth_coverage$plot_read_depth_heatmap$data %>%
      filter(!is.na(var))%>%
      mutate(Read_depth = case_when(
        is.na(Read_depth) ~ 0,
        !is.na(Read_depth) ~ Read_depth
      )) %>%
      summarise(amplified_amplicons1 = sum(Read_depth >= 1)/nrow(ampseq_object_abd1@markers),
                amplified_amplicons5 = sum(Read_depth >= 5)/nrow(ampseq_object_abd1@markers),
                amplified_amplicons10 = sum(Read_depth >= 10)/nrow(ampseq_object_abd1@markers),
                amplified_amplicons20 = sum(Read_depth >= 20)/nrow(ampseq_object_abd1@markers),
                amplified_amplicons50 = sum(Read_depth >= 50)/nrow(ampseq_object_abd1@markers),
                amplified_amplicons100 = sum(Read_depth >= 100)/nrow(ampseq_object_abd1@markers),
                Variable1 = unique(var),
                .by = Sample_id) %>%
      pivot_longer(cols = starts_with('amplified_amplicons'), values_to = 'AmpRate', names_to = 'Threshold') %>%
      mutate(Threshold = as.integer(gsub('amplified_amplicons', '', Threshold)))
    
    if(!(min_abd %in% c(1,5,10,20,50,100))){
      
      sample_performance = rbind(sample_performance,
                                 ReadDepth_coverage$plot_read_depth_heatmap$data %>%
                                   filter(!is.na(var))%>%
                                   mutate(Read_depth = case_when(
                                     is.na(Read_depth) ~ 0,
                                     !is.na(Read_depth) ~ Read_depth
                                   )) %>%
                                   summarise(AmpRate = sum(Read_depth >= min_abd)/nrow(ampseq_object_abd1@markers),
                                             Variable1 = unique(var),
                                             .by = Sample_id) %>%
                                   mutate(Threshold = min_abd) %>%
                                   select(Sample_id, Variable1, Threshold, AmpRate))
      
    }
    
    plot_precentage_of_samples_over_min_abd_byVariable1 = sample_performance %>%
      summarise(AmpRate5 = round(100*sum(AmpRate >= .05)/n(), 1),
                AmpRate10 = round(100*sum(AmpRate >= .10)/n(), 1),
                AmpRate15 = round(100*sum(AmpRate >= .15)/n(), 1),
                AmpRate20 = round(100*sum(AmpRate >= .20)/n(), 1),
                AmpRate25 = round(100*sum(AmpRate >= .25)/n(), 1),
                AmpRate30 = round(100*sum(AmpRate >= .30)/n(), 1),
                AmpRate35 = round(100*sum(AmpRate >= .35)/n(), 1),
                AmpRate40 = round(100*sum(AmpRate >= .40)/n(), 1),
                AmpRate45 = round(100*sum(AmpRate >= .45)/n(), 1),
                AmpRate50 = round(100*sum(AmpRate >= .50)/n(), 1),
                AmpRate55 = round(100*sum(AmpRate >= .55)/n(), 1),
                AmpRate60 = round(100*sum(AmpRate >= .60)/n(), 1),
                AmpRate65 = round(100*sum(AmpRate >= .65)/n(), 1),
                AmpRate70 = round(100*sum(AmpRate >= .70)/n(), 1),
                AmpRate75 = round(100*sum(AmpRate >= .75)/n(), 1),
                AmpRate80 = round(100*sum(AmpRate >= .80)/n(), 1),
                AmpRate85 = round(100*sum(AmpRate >= .85)/n(), 1),
                AmpRate90 = round(100*sum(AmpRate >= .90)/n(), 1),
                AmpRate95 = round(100*sum(AmpRate >= .95)/n(), 1),
                AmpRate100 = round(100*sum(AmpRate >= 1)/n(), 1),
                .by = c(Threshold, Variable1)
      ) %>%
      pivot_longer(cols = paste0('AmpRate', seq(5, 100, 5)),
                   values_to = 'Percentage',
                   names_to = 'AmpRate') %>%
      mutate(AmpRate = as.numeric(gsub('AmpRate','', AmpRate)))%>%
      ggplot(aes(x = AmpRate, y = Percentage, color = as.factor(Threshold), group = as.factor(Threshold))) +
      geom_line() +
      geom_vline(xintercept = 100*sample_ampl_rate, linetype = 2) +
      facet_wrap(Variable1~., ncol = 3)+
      theme_bw() +
      labs(x = '% of amplified loci (amplification rate)', y = '% of Samples', color = 'Min Coverage')
    
  }
  
}
  
## Identification of off target-products and PCR artifacts----

### Off-target products----

if(!is.null(off_target_formula)){
  
  off_target_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta)
  
  off_target_formula_check = off_target_formula
  
  print('Check filters to be applied for removing off-target products')
  
  if(grepl("(h_ij|h_ijminor|p_ij|P_ij|H_ij|H_ijminor|nVSITES_ij|dVSITES_ij|nSNVs_ij|dSNVs_ij|nINDELs_ij|dINDELs_ij|flanking_INDEL)(<|>|!|=)+", off_target_formula_check)){
    stop("All mathematical and logical operators must be separated by blank spaces in off_target_formula_check")
  }
  
  # modify off_target_formula_check
  
  if(grepl("flanking_INDEL ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "flanking_INDEL (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "flanking_INDEL (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("flanking_INDEL ", "off_target_stats[['flanking_INDEL']] ", off_target_formula_check)
    }else{
      stop("Filter flanking_INDEL is been called but there are spelling issues in this part of the off_target_formula_check")
    }
  }
  
  
  if(grepl("dINDELs_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "dINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "dINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("dINDELs_ij ", "off_target_stats[['dINDELs_ij']] ", off_target_formula_check)
    }else{
      stop("Filter dINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nINDELs_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "nINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "nINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("nINDELs_ij ", "off_target_stats[['nINDELs_ij']] ", off_target_formula_check)
    }else{
      stop("Filter nINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dSNVs_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "dSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "dSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("dSNVs_ij ", "off_target_stats[['dSNVs_ij']] ", off_target_formula_check)
    }else{
      stop("Filter dSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nSNVs_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "nSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "nSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("nSNVs_ij ", "off_target_stats[['nSNVs_ij']] ", off_target_formula_check)
    }else{
      stop("Filter nSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dVSITES_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "dVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "dVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("dVSITES_ij ", "off_target_stats[['dVSITES_ij']] ", off_target_formula_check)
    }else{
      stop("Filter dVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nVSITES_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "nVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "nVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("nVSITES_ij ", "off_target_stats[['nVSITES_ij']] ", off_target_formula_check)
    }else{
      stop("Filter nVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("h_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "h_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("h_ij ", "off_target_stats[['h_ij']] ", off_target_formula_check)
    }else{
      stop("Filter h_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("h_ijminor ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "h_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("h_ijminor ", "off_target_stats[['h_ijminor']] ", off_target_formula_check)
    }else{
      stop("Filter h_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("p_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "p_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "p_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("p_ij ", "off_target_stats[['p_ij']] ", off_target_formula_check)
    }else{
      stop("Filter p_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("P_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "P_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "P_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("P_ij ", "off_target_stats[['P_ij']] ", off_target_formula_check)
    }else{
      stop("Filter P_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ij ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "H_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "H_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("H_ij ", "off_target_stats[['H_ij']] ", off_target_formula_check)
    }else{
      stop("Filter H_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ijminor ", off_target_formula_check)){
    
    mask_filter = str_extract(off_target_formula_check, "H_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(off_target_formula_check, "H_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      off_target_formula_check = gsub("H_ijminor ", "off_target_stats[['H_ijminor']] ", off_target_formula_check)
    }else{
      stop("Filter H_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  mask_formula_check = str_split(off_target_formula_check, "&|\\|")[[1]]
  mask_formula_check  = mask_formula_check[!grepl("off_target_stats", mask_formula_check)]
  
  
  if(length(mask_formula_check) > 0){
    for(wrong_filter in mask_formula_check){
      print(paste0("Spelling error with filter ", wrong_filter))
    }
    stop("Execution halted, revise mask_filter argument.\nPossible filters are:\nh_ij, h_ijminor, p_ij, P_ij, H_ij, H_ijminor, nVSITES_ij, dVSITES_ij, nSNVs_ij, dSNVs_ij, nINDELs_ij, dINDELs_ij, flanking_INDEL")
  }
  
  n_off_target_alleles = length(off_target_stats[eval(parse(text = off_target_formula_check)),][['Allele']])
  
  
  if(PerformanceReport){
    
    h_ij_thres = as.numeric(gsub('h_ij (=|!|>|<)+ ',
                                 '',
                                 str_extract(off_target_formula,
                                             "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    h_ijminor_thres = as.numeric(gsub('h_ijminor (=|!|>|<)+ ',
                                      '',
                                      str_extract(off_target_formula,
                                                  "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    dVSITES_ij_thres = as.numeric(gsub('dVSITES_ij (=|!|>|<)+ ',
                                       '',
                                       str_extract(off_target_formula,
                                                   "dVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    plot_off_target_stats = off_target_stats %>%
      ggplot(aes(x= dVSITES_ij)) + 
      geom_vline(xintercept = dVSITES_ij_thres,
                 linetype = 2) +
      geom_histogram(binwidth = 0.01) + 
      theme_bw()
    
    if(!is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_off_target_stats2 = off_target_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ),
        dVSITES_ij_cat = case_when(
          dVSITES_ij >= dVSITES_ij_thres ~ 'Removed',
          dVSITES_ij < dVSITES_ij_thres ~ 'Kept'
        )
        )%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor,
                   size = dVSITES_ij))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(dVSITES_ij_cat~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(!is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_off_target_stats2 = off_target_stats %>%
        mutate(dVSITES_ij_cat = case_when(
          dVSITES_ij >= dVSITES_ij_thres ~ 'Removed',
          dVSITES_ij < dVSITES_ij_thres ~ 'Kept'
        )
        ) %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor,
                   size = dVSITES_ij))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(dVSITES_ij_cat~.)+
        labs(x = 'Alternative allele perv. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_off_target_stats2 = off_target_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ),
        dVSITES_ij_cat = case_when(
          dVSITES_ij >= dVSITES_ij_thres ~ 'Removed',
          dVSITES_ij < dVSITES_ij_thres ~ 'Kept'
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor,
                   size = dVSITES_ij))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(dVSITES_ij_cat~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_off_target_stats2 = off_target_stats %>%
        mutate(dVSITES_ij_cat = case_when(
          dVSITES_ij >= dVSITES_ij_thres ~ 'Removed',
          dVSITES_ij < dVSITES_ij_thres ~ 'Kept'
        )) %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor,
                   size = dVSITES_ij))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(dVSITES_ij_cat~.)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }
    
    
    plot_off_target_stats = ggdraw()+
      draw_plot(plot_off_target_stats, 
                x = 0, width = .4,
                y = 0, height = 1)+
      draw_plot(plot_off_target_stats2, 
                x = .4, width = .6,
                y = 0, height = 1)
    
  }
  
  
  if(n_off_target_alleles > 0){
    
    print(paste0(n_off_target_alleles, ' allele(s) matches the criteria to define off-target products'))
    ampseq_object = mask_alt_alleles(ampseq_object, mask_formula = off_target_formula, ref_fasta = amplicon_fasta)
    
  }else{
    
    print('No allele matches the criteria to define off-target products')
    
  }
  

}else{
  
  if(PerformanceReport){
    
    off_target_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta)
    
    h_ij_thres = 0.66
    h_ijminor_thres = 0.66
    dVSITES_ij_thres = 0.3
    
    plot_off_target_stats = off_target_stats %>%
      ggplot(aes(x= dVSITES_ij)) + 
      geom_vline(xintercept = dVSITES_ij_thres,
                 linetype = 2) +
      geom_histogram(binwidth = 0.01) + 
      theme_bw()
    
    plot_off_target_stats2 = off_target_stats %>%
      mutate(h_ijminor_cat = case_when(
        h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
        h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
      ),
      dVSITES_ij_cat = case_when(
        dVSITES_ij >= dVSITES_ij_thres ~ 'Removed',
        dVSITES_ij < dVSITES_ij_thres ~ 'Kept'
      )
      )%>%
      ggplot(aes(x = p_ij, 
                 y = h_ij,
                 color = h_ijminor,
                 size = dVSITES_ij))+
      geom_point()+
      geom_hline(yintercept = h_ij_thres,
                 linetype = 2) +
      theme_bw()+
      scale_color_continuous(type = 'viridis')+
      facet_grid(dVSITES_ij_cat~h_ijminor_cat)+
      labs(x = 'Alternative allele prev. (p_ij)',
           y = 'h_ij (H_ij/P_ij)',
           color = 'h_ijminor')
    
    plot_off_target_stats = ggdraw()+
      draw_plot(plot_off_target_stats, 
                x = 0, width = .4,
                y = 0, height = 1)+
      draw_plot(plot_off_target_stats2, 
                x = .4, width = .6,
                y = 0, height = 1)
    
    n_off_target_alleles = 0
    
    print('None off-target product will be removed')
    
  }
  
}


### Products with INDELs in their flanking region----


if(!is.null(flanking_INDEL_formula)){
  
  flanking_INDEL_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta)
  
  flanking_INDEL_formula_check = flanking_INDEL_formula
  
  print('Check filters to be applied for removing off-target products')
  
  if(grepl("(h_ij|h_ijminor|p_ij|P_ij|H_ij|H_ijminor|nVSITES_ij|dVSITES_ij|nSNVs_ij|dSNVs_ij|nINDELs_ij|dINDELs_ij|flanking_INDEL)(<|>|!|=)+", flanking_INDEL_formula_check)){
    stop("All mathematical and logical operators must be separated by blank spaces in flanking_INDEL_formula_check")
  }
  
  # modify flanking_INDEL_formula_check
  
  
  if(grepl("flanking_INDEL ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "flanking_INDEL (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "flanking_INDEL (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("flanking_INDEL ", "flanking_INDEL_stats[['flanking_INDEL']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter flanking_INDEL is been called but there are spelling issues in this part of the flanking_INDEL_formula_check")
    }
  }
  
  
  if(grepl("dINDELs_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "dINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "dINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("dINDELs_ij ", "flanking_INDEL_stats[['dINDELs_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter dINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nINDELs_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "nINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "nINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("nINDELs_ij ", "flanking_INDEL_stats[['nINDELs_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter nINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dSNVs_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "dSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "dSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("dSNVs_ij ", "flanking_INDEL_stats[['dSNVs_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter dSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nSNVs_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "nSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "nSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("nSNVs_ij ", "flanking_INDEL_stats[['nSNVs_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter nSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dVSITES_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "dVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "dVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("dVSITES_ij ", "flanking_INDEL_stats[['dVSITES_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter dVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nVSITES_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "nVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "nVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("nVSITES_ij ", "flanking_INDEL_stats[['nVSITES_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter nVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("h_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "h_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("h_ij ", "flanking_INDEL_stats[['h_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter h_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("h_ijminor ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "h_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("h_ijminor ", "flanking_INDEL_stats[['h_ijminor']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter h_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("p_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "p_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "p_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("p_ij ", "flanking_INDEL_stats[['p_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter p_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("P_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "P_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "P_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("P_ij ", "flanking_INDEL_stats[['P_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter P_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ij ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "H_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "H_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("H_ij ", "flanking_INDEL_stats[['H_ij']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter H_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ijminor ", flanking_INDEL_formula_check)){
    
    mask_filter = str_extract(flanking_INDEL_formula_check, "H_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(flanking_INDEL_formula_check, "H_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      flanking_INDEL_formula_check = gsub("H_ijminor ", "flanking_INDEL_stats[['H_ijminor']] ", flanking_INDEL_formula_check)
    }else{
      stop("Filter H_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  mask_formula_check = str_split(flanking_INDEL_formula_check, "&|\\|")[[1]]
  mask_formula_check  = mask_formula_check[!grepl("flanking_INDEL_stats", mask_formula_check)]
  
  
  if(length(mask_formula_check) > 0){
    for(wrong_filter in mask_formula_check){
      print(paste0("Spelling error with filter ", wrong_filter))
    }
    stop("Execution halted, revise mask_filter argument.\nPossible filters are:\nh_ij, h_ijminor, p_ij, P_ij, H_ij, H_ijminor, nVSITES_ij, dVSITES_ij, nSNVs_ij, dSNVs_ij, nINDELs_ij, dINDELs_ij, flanking_INDEL")
  }
  
  # Count number of alleles to be filtered
  
  n_flanking_INDEL_alleles = length(flanking_INDEL_stats[eval(parse(text = flanking_INDEL_formula_check)),][['Allele']])
  
  if(PerformanceReport){
    
    h_ij_thres = as.numeric(gsub('h_ij (=|!|>|<)+ ',
                                 '',
                                 str_extract(flanking_INDEL_formula,
                                             "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    h_ijminor_thres = as.numeric(gsub('h_ijminor (=|!|>|<)+ ',
                                      '',
                                      str_extract(flanking_INDEL_formula,
                                                  "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    if(!is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_flanking_INDEL_stats = flanking_INDEL_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(flanking_INDEL~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(!is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_flanking_INDEL_stats = flanking_INDEL_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(flanking_INDEL~.)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_flanking_INDEL_stats = flanking_INDEL_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(flanking_INDEL~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_flanking_INDEL_stats = flanking_INDEL_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(flanking_INDEL~.)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }
    
  }
  
  if(n_flanking_INDEL_alleles > 0){
    
    print(paste0(n_flanking_INDEL_alleles, ' allele(s) matches the criteria to identify products with flanking INDELs'))
    # mask flanking_INDEL
    
    flanking_INDEL_stats2 = get_ASVs_attributes(ampseq_object,  ref_fasta = amplicon_fasta)
    while(sum(flanking_INDEL_stats2$flanking_INDEL) > 0){
      ampseq_object = mask_alt_alleles(ampseq_object, mask_formula = flanking_INDEL_formula, ref_fasta = amplicon_fasta)
      flanking_INDEL_stats2 = get_ASVs_attributes(ampseq_object,  ref_fasta = amplicon_fasta)
    }
  }else{
    
    print('No allele matches the criteria to identify products with flanking INDELs')
    
  }
  
}else{
  
  if(PerformanceReport){
    
    flanking_INDEL_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta)
    
    h_ij_thres = 0.66
    h_ijminor_thres = 0.66
    
    plot_flanking_INDEL_stats = flanking_INDEL_stats %>%
      mutate(h_ijminor_cat = case_when(
        h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
        h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
      ))%>%
      ggplot(aes(x = p_ij, 
                 y = h_ij,
                 color = h_ijminor))+
      geom_point()+
      geom_hline(yintercept = h_ij_thres,
                 linetype = 2) +
      theme_bw()+
      scale_color_continuous(type = 'viridis')+
      facet_grid(flanking_INDEL~h_ijminor_cat)+
      labs(x = 'Alternative allele prev. (p_ij)',
           y = 'h_ij (H_ij/P_ij)',
           color = 'h_ijminor')
    
    n_flanking_INDEL_alleles = 0
    
    print('None product with flanking INDELs will be masked')
    
  }
  
}

### Systematic PCR Errors SNVs in homopolymers ----

if(!is.null(SNV_in_homopolymer_formula)){
  
  SNV_in_homopolymer_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta, homopolymer_length = homopolymer_length)
  
  SNV_in_homopolymer_formula_check = SNV_in_homopolymer_formula
  
  print('Check filters to be applied for removing off-target products')
  
  if(grepl("(h_ij|h_ijminor|p_ij|P_ij|H_ij|H_ijminor|nVSITES_ij|dVSITES_ij|nSNVs_ij|dSNVs_ij|nINDELs_ij|dINDELs_ij|flanking_INDEL)(<|>|!|=)+", SNV_in_homopolymer_formula_check)){
    stop("All mathematical and logical operators must be separated by blank spaces in SNV_in_homopolymer_formula_check")
  }
  
  # modify PCR_errors_formula_check
  
  
  if(grepl("flanking_INDEL ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "flanking_INDEL (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "flanking_INDEL (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("flanking_INDEL ", "SNV_in_homopolymer_stats[['flanking_INDEL']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter flanking_INDEL is been called but there are spelling issues in this part of the SNV_in_homopolymer_formula_check")
    }
  }
  
  
  if(grepl("dINDELs_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "dINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "dINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("dINDELs_ij ", "SNV_in_homopolymer_stats[['dINDELs_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter dINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nINDELs_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "nINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "nINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("nINDELs_ij ", "SNV_in_homopolymer_stats[['nINDELs_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter nINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dSNVs_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "dSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "dSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("dSNVs_ij ", "SNV_in_homopolymer_stats[['dSNVs_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter dSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nSNVs_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "nSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "nSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("nSNVs_ij ", "SNV_in_homopolymer_stats[['nSNVs_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter nSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dVSITES_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "dVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "dVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("dVSITES_ij ", "SNV_in_homopolymer_stats[['dVSITES_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter dVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nVSITES_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "nVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "nVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("nVSITES_ij ", "SNV_in_homopolymer_stats[['nVSITES_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter nVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("h_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "h_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("h_ij ", "SNV_in_homopolymer_stats[['h_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter h_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("h_ijminor ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "h_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("h_ijminor ", "SNV_in_homopolymer_stats[['h_ijminor']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter h_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("p_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "p_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "p_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("p_ij ", "SNV_in_homopolymer_stats[['p_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter p_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("P_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "P_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "P_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("P_ij ", "SNV_in_homopolymer_stats[['P_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter P_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ij ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "H_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "H_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("H_ij ", "SNV_in_homopolymer_stats[['H_ij']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter H_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ijminor ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "H_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "H_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("H_ijminor ", "SNV_in_homopolymer_stats[['H_ijminor']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter H_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("SNV_in_homopolymer ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "SNV_in_homopolymer (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "SNV_in_homopolymer (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("SNV_in_homopolymer ", "SNV_in_homopolymer_stats[['SNV_in_homopolymer']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter SNV_in_homopolymer is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("INDEL_in_homopolymer ", SNV_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(SNV_in_homopolymer_formula_check, "INDEL_in_homopolymer (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(SNV_in_homopolymer_formula_check, "INDEL_in_homopolymer (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("INDEL_in_homopolymer ", "SNV_in_homopolymer_stats[['INDEL_in_homopolymer']] ", SNV_in_homopolymer_formula_check)
    }else{
      stop("Filter INDEL_in_homopolymer is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  mask_formula_check = str_split(SNV_in_homopolymer_formula_check, "&|\\|")[[1]]
  mask_formula_check  = mask_formula_check[!grepl("SNV_in_homopolymer_stats", mask_formula_check)]
  
  
  if(length(mask_formula_check) > 0){
    for(wrong_filter in mask_formula_check){
      print(paste0("Spelling error with filter ", wrong_filter))
    }
    stop("Execution halted, revise mask_filter argument.\nPossible filters are:\nh_ij, h_ijminor, p_ij, P_ij, H_ij, H_ijminor, nVSITES_ij, dVSITES_ij, nSNVs_ij, dSNVs_ij, nINDELs_ij, dINDELs_ij, flanking_INDEL")
  }
  
  # Count number of alleles to be filtered
  
  n_SNV_in_homopolymer_alleles = length(SNV_in_homopolymer_stats[eval(parse(text = SNV_in_homopolymer_formula_check)),][['Allele']])
  
  
  if(PerformanceReport){
    
    h_ij_thres = as.numeric(gsub('h_ij (=|!|>|<)+ ',
                                 '',
                                 str_extract(SNV_in_homopolymer_formula,
                                             "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    h_ijminor_thres = as.numeric(gsub('h_ijminor (=|!|>|<)+ ',
                                      '',
                                      str_extract(SNV_in_homopolymer_formula,
                                                  "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    if(!is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_SNV_in_homopolymer_stats = SNV_in_homopolymer_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(SNV_in_homopolymer~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(!is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_SNV_in_homopolymer_stats = SNV_in_homopolymer_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(SNV_in_homopolymer~.)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_SNV_in_homopolymer_stats = SNV_in_homopolymer_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(SNV_in_homopolymer~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_SNV_in_homopolymer_stats = SNV_in_homopolymer_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(SNV_in_homopolymer~.)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }
    
  }
  
  if(n_SNV_in_homopolymer_alleles > 0){
    
    print(paste0(n_SNV_in_homopolymer_alleles, ' allele(s) matches the criteria to identify SNV_in_homopolymer'))
    
    # masking SNVs in homopolymers
    ampseq_object = mask_alt_alleles(ampseq_object, mask_formula = SNV_in_homopolymer_formula, ref_fasta = amplicon_fasta, homopolymer_length = homopolymer_length)
    
    print('gt_masked generated')
    
  }else{
    
    print('No allele matches the criteria to identify SNV_in_homopolymer')
    
  }
  
}else{
  
  if(PerformanceReport){
    
    SNV_in_homopolymer_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta, homopolymer_length = homopolymer_length)
    
    h_ij_thres = 0.66
    
    h_ijminor_thres = 0.66
    
    plot_SNV_in_homopolymer_stats = SNV_in_homopolymer_stats %>%
      mutate(h_ijminor_cat = case_when(
        h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
        h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
      ))%>%
      ggplot(aes(x = p_ij, 
                 y = h_ij,
                 color = h_ijminor))+
      geom_point()+
      geom_hline(yintercept = h_ij_thres,
                 linetype = 2) +
      theme_bw()+
      scale_color_continuous(type = 'viridis')+
      facet_grid(SNV_in_homopolymer~h_ijminor_cat)+
      labs(x = 'Alternative allele prev. (p_ij)',
           y = 'h_ij (H_ij/P_ij)',
           color = 'h_ijminor')
    
    n_SNV_in_homopolymer_alleles = 0
    
    print('None SNV_in_homopolymer will be masked')
    
  }
  
}


### Systematic PCR Errors INDELs in homopolymers ----

if(!is.null(INDEL_in_homopolymer_formula)){
  
  INDEL_in_homopolymer_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta, homopolymer_length = homopolymer_length)
  
  INDEL_in_homopolymer_formula_check = INDEL_in_homopolymer_formula
  
  print('Check filters to be applied for removing off-target products')
  
  if(grepl("(h_ij|h_ijminor|p_ij|P_ij|H_ij|H_ijminor|nVSITES_ij|dVSITES_ij|nSNVs_ij|dSNVs_ij|nINDELs_ij|dINDELs_ij|flanking_INDEL)(<|>|!|=)+", INDEL_in_homopolymer_formula_check)){
    stop("All mathematical and logical operators must be separated by blank spaces in INDEL_in_homopolymer_formula_check")
  }
  
  # modify INDEL_in_homopolymer_formula_check
  
  
  if(grepl("flanking_INDEL ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "flanking_INDEL (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "flanking_INDEL (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("flanking_INDEL ", "INDEL_in_homopolymer_stats[['flanking_INDEL']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter flanking_INDEL is been called but there are spelling issues in this part of the INDEL_in_homopolymer_formula_check")
    }
  }
  
  
  if(grepl("dINDELs_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "dINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "dINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("dINDELs_ij ", "INDEL_in_homopolymer_stats[['dINDELs_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter dINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nINDELs_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "nINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "nINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("nINDELs_ij ", "INDEL_in_homopolymer_stats[['nINDELs_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter nINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dSNVs_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "dSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "dSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("dSNVs_ij ", "INDEL_in_homopolymer_stats[['dSNVs_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter dSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nSNVs_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "nSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "nSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("nSNVs_ij ", "INDEL_in_homopolymer_stats[['nSNVs_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter nSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dVSITES_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "dVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "dVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("dVSITES_ij ", "INDEL_in_homopolymer_stats[['dVSITES_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter dVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nVSITES_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "nVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "nVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("nVSITES_ij ", "INDEL_in_homopolymer_stats[['nVSITES_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter nVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("h_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "h_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("h_ij ", "INDEL_in_homopolymer_stats[['h_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter h_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("h_ijminor ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "h_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("h_ijminor ", "INDEL_in_homopolymer_stats[['h_ijminor']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter h_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("p_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "p_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "p_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("p_ij ", "INDEL_in_homopolymer_stats[['p_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter p_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("P_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "P_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "P_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("P_ij ", "INDEL_in_homopolymer_stats[['P_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter P_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ij ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "H_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "H_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("H_ij ", "INDEL_in_homopolymer_stats[['H_ij']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter H_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ijminor ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "H_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "H_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("H_ijminor ", "INDEL_in_homopolymer_stats[['H_ijminor']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter H_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("SNV_in_homopolymer ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "SNV_in_homopolymer (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "INDEL_in_homopolymer (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("SNV_in_homopolymer ", "INDEL_in_homopolymer_stats[['SNV_in_homopolymer']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter INDEL_in_homopolymer is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("INDEL_in_homopolymer ", INDEL_in_homopolymer_formula_check)){
    
    mask_filter = str_extract(INDEL_in_homopolymer_formula_check, "INDEL_in_homopolymer (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(INDEL_in_homopolymer_formula_check, "INDEL_in_homopolymer (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      INDEL_in_homopolymer_formula_check = gsub("INDEL_in_homopolymer ", "INDEL_in_homopolymer_stats[['INDEL_in_homopolymer']] ", INDEL_in_homopolymer_formula_check)
    }else{
      stop("Filter INDEL_in_homopolymer is been called but there are spelling issues in this part of the formula")
    }
  }
  
  mask_formula_check = str_split(INDEL_in_homopolymer_formula_check, "&|\\|")[[1]]
  mask_formula_check  = mask_formula_check[!grepl("INDEL_in_homopolymer_stats", mask_formula_check)]
  
  
  if(length(mask_formula_check) > 0){
    for(wrong_filter in mask_formula_check){
      print(paste0("Spelling error with filter ", wrong_filter))
    }
    stop("Execution halted, revise mask_filter argument.\nPossible filters are:\nh_ij, h_ijminor, p_ij, P_ij, H_ij, H_ijminor, nVSITES_ij, dVSITES_ij, nSNVs_ij, dSNVs_ij, nINDELs_ij, dINDELs_ij, flanking_INDEL")
  }
  
  # Count number of alleles to be filtered
  
  n_INDEL_in_homopolymer_alleles = length(INDEL_in_homopolymer_stats[eval(parse(text = INDEL_in_homopolymer_formula_check)),][['Allele']])
  
  
  if(PerformanceReport){
    
    h_ij_thres = as.numeric(gsub('h_ij (=|!|>|<)+ ',
                                 '',
                                 str_extract(INDEL_in_homopolymer_formula,
                                             "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    h_ijminor_thres = as.numeric(gsub('h_ijminor (=|!|>|<)+ ',
                                      '',
                                      str_extract(INDEL_in_homopolymer_formula,
                                                  "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    if(!is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_INDEL_in_homopolymer_stats = INDEL_in_homopolymer_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(INDEL_in_homopolymer~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(!is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_INDEL_in_homopolymer_stats = INDEL_in_homopolymer_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(INDEL_in_homopolymer~.)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_INDEL_in_homopolymer_stats = INDEL_in_homopolymer_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(INDEL_in_homopolymer~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_INDEL_in_homopolymer_stats = INDEL_in_homopolymer_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(INDEL_in_homopolymer~.)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }
    
  }
  
  if(n_INDEL_in_homopolymer_alleles > 0){
    
    print(paste0(n_INDEL_in_homopolymer_alleles, ' allele(s) matches the criteria to identify INDEL_in_homopolymer'))
    
    # masking INDELs in homopolymers
    ampseq_object = mask_alt_alleles(obj = ampseq_object, mask_formula = INDEL_in_homopolymer_formula, ref_fasta = amplicon_fasta, homopolymer_length = homopolymer_length)
    
    print('gt_masked generated')

    
  }else{
    
    print('No allele matches the criteria to identify INDEL_in_homopolymer')
    
  }
  
}else{
  
  if(PerformanceReport){
    
    INDEL_in_homopolymer_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta, homopolymer_length = homopolymer_length)
    
    h_ij_thres = 0.66
    
    h_ijminor_thres = 0.66
    
    plot_INDEL_in_homopolymer_stats = INDEL_in_homopolymer_stats %>%
      mutate(h_ijminor_cat = case_when(
        h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
        h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
      ))%>%
      ggplot(aes(x = p_ij, 
                 y = h_ij,
                 color = h_ijminor))+
      geom_point()+
      geom_hline(yintercept = h_ij_thres,
                 linetype = 2) +
      theme_bw()+
      scale_color_continuous(type = 'viridis')+
      facet_grid(INDEL_in_homopolymer~h_ijminor_cat)+
      labs(x = 'Alternative allele prev. (p_ij)',
           y = 'h_ij (H_ij/P_ij)',
           color = 'h_ijminor')
    
    n_INDEL_in_homopolymer_alleles = 0
    
    print('None INDEL_in_homopolymer will be masked')
    
  }
  
}

### Systematic PCR Errors bimeras ----

if(!is.null(bimera_formula)){
  
  bimera_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta, homopolymer_length = homopolymer_length)
  
  bimera_formula_check = bimera_formula
  
  print('Check filters to be applied for removing off-target products')
  
  if(grepl("(h_ij|h_ijminor|p_ij|P_ij|H_ij|H_ijminor|nVSITES_ij|dVSITES_ij|nSNVs_ij|dSNVs_ij|nINDELs_ij|dINDELs_ij|flanking_INDEL)(<|>|!|=)+", bimera_formula_check)){
    stop("All mathematical and logical operators must be separated by blank spaces in bimera_formula_check")
  }
  
  # modify bimera_formula_check
  
  
  if(grepl("flanking_INDEL ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "flanking_INDEL (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "flanking_INDEL (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("flanking_INDEL ", "bimera_stats[['flanking_INDEL']] ", bimera_formula_check)
    }else{
      stop("Filter flanking_INDEL is been called but there are spelling issues in this part of the bimera_formula_check")
    }
  }
  
  
  if(grepl("dINDELs_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "dINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "dINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("dINDELs_ij ", "bimera_stats[['dINDELs_ij']] ", bimera_formula_check)
    }else{
      stop("Filter dINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nINDELs_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "nINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "nINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("nINDELs_ij ", "bimera_stats[['nINDELs_ij']] ", bimera_formula_check)
    }else{
      stop("Filter nINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dSNVs_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "dSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "dSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("dSNVs_ij ", "bimera_stats[['dSNVs_ij']] ", bimera_formula_check)
    }else{
      stop("Filter dSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nSNVs_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "nSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "nSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("nSNVs_ij ", "bimera_stats[['nSNVs_ij']] ", bimera_formula_check)
    }else{
      stop("Filter nSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dVSITES_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "dVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "dVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("dVSITES_ij ", "bimera_stats[['dVSITES_ij']] ", bimera_formula_check)
    }else{
      stop("Filter dVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nVSITES_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "nVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "nVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("nVSITES_ij ", "bimera_stats[['nVSITES_ij']] ", bimera_formula_check)
    }else{
      stop("Filter nVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("h_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "h_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("h_ij ", "bimera_stats[['h_ij']] ", bimera_formula_check)
    }else{
      stop("Filter h_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("h_ijminor ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "h_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("h_ijminor ", "bimera_stats[['h_ijminor']] ", bimera_formula_check)
    }else{
      stop("Filter h_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("p_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "p_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "p_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("p_ij ", "bimera_stats[['p_ij']] ", bimera_formula_check)
    }else{
      stop("Filter p_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("P_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "P_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "P_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("P_ij ", "bimera_stats[['P_ij']] ", bimera_formula_check)
    }else{
      stop("Filter P_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ij ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "H_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "H_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("H_ij ", "bimera_stats[['H_ij']] ", bimera_formula_check)
    }else{
      stop("Filter H_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ijminor ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "H_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "H_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("H_ijminor ", "bimera_stats[['H_ijminor']] ", bimera_formula_check)
    }else{
      stop("Filter H_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("SNV_in_homopolymer ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "SNV_in_homopolymer (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "INDEL_in_homopolymer (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      SNV_in_homopolymer_formula_check = gsub("SNV_in_homopolymer ", "bimera_stats[['SNV_in_homopolymer']] ", bimera_formula_check)
    }else{
      stop("Filter INDEL_in_homopolymer is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("INDEL_in_homopolymer ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "INDEL_in_homopolymer (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "INDEL_in_homopolymer (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("INDEL_in_homopolymer ", "bimera_stats[['INDEL_in_homopolymer']] ", bimera_formula_check)
    }else{
      stop("Filter INDEL_in_homopolymer is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("bimera ", bimera_formula_check)){
    
    mask_filter = str_extract(bimera_formula_check, "bimera (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(bimera_formula_check, "bimera (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      bimera_formula_check = gsub("bimera ", "bimera_stats[['bimera']] ", bimera_formula_check)
    }else{
      stop("Filter bimera is been called but there are spelling issues in this part of the formula")
    }
  }
  
  mask_formula_check = str_split(bimera_formula_check, "&|\\|")[[1]]
  mask_formula_check  = mask_formula_check[!grepl("bimera_stats", mask_formula_check)]
  
  
  if(length(mask_formula_check) > 0){
    for(wrong_filter in mask_formula_check){
      print(paste0("Spelling error with filter ", wrong_filter))
    }
    stop("Execution halted, revise mask_filter argument.\nPossible filters are:\nh_ij, h_ijminor, p_ij, P_ij, H_ij, H_ijminor, nVSITES_ij, dVSITES_ij, nSNVs_ij, dSNVs_ij, nINDELs_ij, dINDELs_ij, flanking_INDEL")
  }
  
  # Count number of alleles to be filtered
  
  n_bimera_alleles = length(bimera_stats[eval(parse(text = bimera_formula_check)),][['Allele']])
  
  
  if(PerformanceReport){
    
    h_ij_thres = as.numeric(gsub('h_ij (=|!|>|<)+ ',
                                 '',
                                 str_extract(bimera_formula,
                                             "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    h_ijminor_thres = as.numeric(gsub('h_ijminor (=|!|>|<)+ ',
                                      '',
                                      str_extract(bimera_formula,
                                                  "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    if(!is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_bimera_stats = bimera_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(bimera~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(!is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_bimera_stats = bimera_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(bimera~.)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_bimera_stats = bimera_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(bimera~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_bimera_stats = bimera_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(bimera~.)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }
    
  }
  
  if(n_bimera_alleles > 0){
    
    print(paste0(n_bimera_alleles, ' allele(s) matches the criteria to identify bimeras'))
    
    # masking INDELs in homopolymers
    ampseq_object = mask_alt_alleles(obj = ampseq_object, mask_formula = bimera_formula, ref_fasta = amplicon_fasta, homopolymer_length = homopolymer_length)
    
    print('gt_masked generated')
    
    
  }else{
    
    print('No allele matches the criteria to identify bimera')
    
  }
  
}else{
  
  if(PerformanceReport){
    
    bimera_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta, homopolymer_length = homopolymer_length)
    
    h_ij_thres = 0.66
    h_ijminor_thres = 0.66
    
    plot_bimera_stats = bimera_stats %>%
      mutate(h_ijminor_cat = case_when(
        h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
        h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
      ))%>%
      ggplot(aes(x = p_ij, 
                 y = h_ij,
                 color = h_ijminor))+
      geom_point()+
      geom_hline(yintercept = h_ij_thres,
                 linetype = 2) +
      theme_bw()+
      scale_color_continuous(type = 'viridis')+
      facet_grid(bimera~h_ijminor_cat)+
      labs(x = 'Alternative allele prev. (p_ij)',
           y = 'h_ij (H_ij/P_ij)',
           color = 'h_ijminor')
    
    n_bimera_alleles = 0
    
    print('None bimera will be masked')
    
  }
  
}

### Stochastic PCR Errors present as heterozygous----

if(!is.null(PCR_errors_formula)){
  
  PCR_errors_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta)
  
  PCR_errors_formula_check = PCR_errors_formula
  
  print('Check filters to be applied for removing off-target products')
  
  if(grepl("(h_ij|h_ijminor|p_ij|P_ij|H_ij|H_ijminor|nVSITES_ij|dVSITES_ij|nSNVs_ij|dSNVs_ij|nINDELs_ij|dINDELs_ij|flanking_INDEL)(<|>|!|=)+", PCR_errors_formula_check)){
    stop("All mathematical and logical operators must be separated by blank spaces in PCR_errors_formula_check")
  }
  
  # modify PCR_errors_formula_check
  
  
  if(grepl("flanking_INDEL ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "flanking_INDEL (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "flanking_INDEL (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("flanking_INDEL ", "PCR_errors_stats[['flanking_INDEL']] ", PCR_errors_formula_check)
    }else{
      stop("Filter flanking_INDEL is been called but there are spelling issues in this part of the PCR_errors_formula_check")
    }
  }
  
  
  if(grepl("dINDELs_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "dINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "dINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("dINDELs_ij ", "PCR_errors_stats[['dINDELs_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter dINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nINDELs_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "nINDELs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "nINDELs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("nINDELs_ij ", "PCR_errors_stats[['nINDELs_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter nINDELs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dSNVs_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "dSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "dSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("dSNVs_ij ", "PCR_errors_stats[['dSNVs_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter dSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nSNVs_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "nSNVs_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "nSNVs_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("nSNVs_ij ", "PCR_errors_stats[['nSNVs_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter nSNVs_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("dVSITES_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "dVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "dVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("dVSITES_ij ", "PCR_errors_stats[['dVSITES_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter dVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("nVSITES_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "nVSITES_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "nVSITES_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("nVSITES_ij ", "PCR_errors_stats[['nVSITES_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter nVSITES_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  
  if(grepl("h_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "h_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("h_ij ", "PCR_errors_stats[['h_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter h_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("h_ijminor ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "h_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("h_ijminor ", "PCR_errors_stats[['h_ijminor']] ", PCR_errors_formula_check)
    }else{
      stop("Filter h_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("p_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "p_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "p_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("p_ij ", "PCR_errors_stats[['p_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter p_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("P_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "P_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "P_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("P_ij ", "PCR_errors_stats[['P_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter P_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ij ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "H_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "H_ij (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("H_ij ", "PCR_errors_stats[['H_ij']] ", PCR_errors_formula_check)
    }else{
      stop("Filter H_ij is been called but there are spelling issues in this part of the formula")
    }
  }
  
  if(grepl("H_ijminor ", PCR_errors_formula_check)){
    
    mask_filter = str_extract(PCR_errors_formula_check, "H_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")
    
    if(!is.na(mask_filter)){
      print(paste0('Filter ', str_extract(PCR_errors_formula_check, "H_ijminor (=|!|>|<)* (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)"), ' will be applied'))
      PCR_errors_formula_check = gsub("H_ijminor ", "PCR_errors_stats[['H_ijminor']] ", PCR_errors_formula_check)
    }else{
      stop("Filter H_ijminor is been called but there are spelling issues in this part of the formula")
    }
  }
  
  mask_formula_check = str_split(PCR_errors_formula_check, "&|\\|")[[1]]
  mask_formula_check  = mask_formula_check[!grepl("PCR_errors_stats", mask_formula_check)]
  
  
  if(length(mask_formula_check) > 0){
    for(wrong_filter in mask_formula_check){
      print(paste0("Spelling error with filter ", wrong_filter))
    }
    stop("Execution halted, revise mask_filter argument.\nPossible filters are:\nh_ij, h_ijminor, p_ij, P_ij, H_ij, H_ijminor, nVSITES_ij, dVSITES_ij, nSNVs_ij, dSNVs_ij, nINDELs_ij, dINDELs_ij, flanking_INDEL")
  }
  
  # Count number of alleles to be filtered
  
  n_PCR_errors_alleles = length(PCR_errors_stats[eval(parse(text = PCR_errors_formula_check)),][['Allele']])
  
  
  if(PerformanceReport){
    
    h_ij_thres = as.numeric(gsub('h_ij (=|!|>|<)+ ',
                                 '',
                                 str_extract(PCR_errors_formula,
                                             "h_ij (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    h_ijminor_thres = as.numeric(gsub('h_ijminor (=|!|>|<)+ ',
                                      '',
                                      str_extract(PCR_errors_formula,
                                                  "h_ijminor (=|!|>|<)+ (\\d+\\.?\\d*|\\d*\\.?\\d+|TRUE|FALSE)")))
    
    if(!is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_PCR_errors_stats = PCR_errors_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(.~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(!is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_PCR_errors_stats = PCR_errors_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        geom_hline(yintercept = h_ij_thres,
                   linetype = 2) +
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & !is.na(h_ijminor_thres)){
      
      plot_PCR_errors_stats = PCR_errors_stats %>%
        mutate(h_ijminor_cat = case_when(
          h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
          h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
        ))%>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        facet_grid(.~h_ijminor_cat)+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }else if(is.na(h_ij_thres) & is.na(h_ijminor_thres)){
      
      plot_PCR_errors_stats = PCR_errors_stats %>%
        ggplot(aes(x = p_ij, 
                   y = h_ij,
                   color = h_ijminor))+
        geom_point()+
        theme_bw()+
        scale_color_continuous(type = 'viridis')+
        labs(x = 'Alternative allele prev. (p_ij)',
             y = 'h_ij (H_ij/P_ij)',
             color = 'h_ijminor')
      
    }
    
  }
  
  if(n_PCR_errors_alleles > 0){
    
    print(paste0(n_PCR_errors_alleles, ' allele(s) matches the criteria to identify PCR_errors'))
    
    # removing PCR_errors_alleles
    ampseq_object = mask_alt_alleles(obj = ampseq_object, mask_formula = PCR_errors_formula, ref_fasta = amplicon_fasta)
    
    print('gt_masked generated')
    
    
  }else{
    
    print('No allele matches the criteria to identify PCR_errors')
    
  }
  
}else{
  
  if(PerformanceReport){
    
    PCR_errors_stats = get_ASVs_attributes(ampseq_object, ref_fasta = amplicon_fasta)
    
    h_ij_thres = 0.66
    
    h_ijminor_thres = 0.66
    
    plot_PCR_errors_stats = PCR_errors_stats %>%
      mutate(h_ijminor_cat = case_when(
        h_ijminor < h_ijminor_thres ~ paste0('h_ijminor < ',h_ijminor_thres),
        h_ijminor >= h_ijminor_thres ~ paste0('h_ijminor >= ',h_ijminor_thres)
      ))%>%
      ggplot(aes(x = p_ij, 
                 y = h_ij,
                 color = h_ijminor))+
      geom_point()+
      geom_hline(yintercept = h_ij_thres,
                 linetype = 2) +
      theme_bw()+
      scale_color_continuous(type = 'viridis')+
      facet_grid(.~h_ijminor_cat)+
      labs(x = 'Alternative allele prev. (p_ij)',
           y = 'h_ij (H_ij/P_ij)',
           color = 'h_ijminor')
    
    n_PCR_errors_alleles = 0
    
    print('None stochastic PCR error will be removed')
    
  }
  
  
}


## Coverage by sample and amplicon----

if(!is.null(metadata_file)){
  # Merge the external metadata with our ampseq_object
  
  external_metadata = read.csv(metadata_file)
  
  # Check duplicate samples
  
  if(sum(duplicated(external_metadata$Sample_id)) > 0){
    
    print(paste0('There are ', sum(duplicated(external_metadata$Sample_id)), ' duplicated Ids that are going to be removed'))
    external_metadata %<>% filter(!duplicated(external_metadata$Sample_id))
    
  }
  
  
  shared_variables = names(ampseq_object@metadata)[names(ampseq_object@metadata) %in% names(external_metadata)]
  shared_variables = shared_variables[!(shared_variables %in% c('Sample_id', join_by))]
  
  if(length(shared_variables) > 0){
    print(paste0('The following variables will be overwritten: ', paste(shared_variables, collapse = ', ')))
    
    for(variable in shared_variables){
      
      ampseq_object@metadata[[variable]] = NULL
      
    }
    
  }

  # Merge the external metadata with our ampseq_object
  
  ampseq_object@metadata = left_join(ampseq_object@metadata,
                                     external_metadata,
                                     by = join_by)
  
  print('external metadata added to ampseq object')
}


if(PerformanceReport == TRUE){
  
  print('Measuring coverage per sample per amplicon')
  
  # Read Depth coverage by the whole dataset or by Variable1
  
  if(is.null(Variable1)){
    ReadDepth_coverage = get_ReadDepth_coverage(ampseq_object, variable = NULL)
  }else{
    ReadDepth_coverage = get_ReadDepth_coverage(ampseq_object, variable = Variable1)
  }
  
  # Read Depth coverage by the whole dataset or by Run
  
  ReadDepth_coverage_by_run = get_ReadDepth_coverage(ampseq_object, variable = "Run")
  
  # Read Depth coverage by the whole dataset or by Run for controls
  
  ampseq_object_controls = filter_samples(ampseq_object, v = ampseq_object@metadata$typeofSamp == 'Controls')
  
  ReadDepth_coverage_by_run_controls = get_ReadDepth_coverage(ampseq_object = ampseq_object_controls, variable = "Run")
  
}

# Remove controls

print('Removing Controls for further steps')

ampseq_object = filter_samples(ampseq_object, v = ampseq_object@metadata$typeofSamp == 'Samples')

if(PerformanceReport){
  ampseq_object@controls[['gt']] = ampseq_object_controls@gt
  ampseq_object@controls[['metadata']] = ampseq_object_controls@metadata
}



print("Removing undesired categories based on var_filter")
if(!is.null(var_filter)){
  filters = strsplit(var_filter,';')
  for(temp_filter in 1:length(filters)){
    
    if(toupper(filters[[temp_filter]][2]) == 'KEEP'){
      
      ampseq_object = filter_samples(ampseq_object,
                                     ampseq_object@metadata[[filters[[temp_filter]][1]]] %in% strsplit(filters[[temp_filter]][3],',')[[1]])
      
    }else if(toupper(filters[[temp_filter]][2]) == 'REMOVE'){
  
      ampseq_object = filter_samples(ampseq_object,
                                     !(ampseq_object@metadata[[filters[[temp_filter]][1]]] %in% strsplit(filters[[temp_filter]][3],',')[[1]]))
      
    }
  }
}

# if locus_ampl_rate was provided

print('Measuring amplification rate by locus')

if(!is.null(locus_ampl_rate)){
  
  if(!is.null(Variable1)){
    ampseq_object = locus_amplification_rate(ampseq_object, threshold = locus_ampl_rate, strata = Variable1)
  }else{
    ampseq_object = locus_amplification_rate(ampseq_object, threshold = locus_ampl_rate)
  }
  
}else{
  
  if(!is.null(Variable1)){
    ampseq_object = locus_amplification_rate(ampseq_object, threshold = 0.65, strata = Variable1)
  }else{
    ampseq_object = locus_amplification_rate(ampseq_object, threshold = 0.65) 
  }
}

# if sample_ampl_rate was provided

print("measuring amplification rate by sample")

if(!is.null(sample_ampl_rate)){
  if(!is.null(Variable1)){
    ampseq_object = sample_amplification_rate(ampseq_object, threshold = sample_ampl_rate, strata = Variable1)
  }else{
    ampseq_object = sample_amplification_rate(ampseq_object, threshold = sample_ampl_rate)  
  }
  
}else{
  
  if(!is.null(Variable1)){
    ampseq_object = sample_amplification_rate(ampseq_object, threshold = 0.80, strata = Variable1)
  }else{
    ampseq_object = sample_amplification_rate(ampseq_object, threshold = 0.80)  
  }

}

## Printing performance report----

if(PerformanceReport == TRUE){
  
  all_loci_amplification_rate = ampseq_object@plots$all_loci_amplification_rate
  
  samples_amplification_rate = ampseq_object@plots$samples_amplification_rate
  
  cigar_table_unmasked_unfiltered = ampseq_object_abd1@gt 
  cigar_table_masked_filtered = ampseq_object@gt
  cigar_table_controls_masked_filtered = ampseq_object_controls@gt
  
  metadata_kept_samples = ampseq_object@metadata
  metadata_removed_samples  = ampseq_object@discarded_samples$metadata
  
  
  print('Generation of plots and tables for Performance report done')
  
  
  Performance_Report_expected_outputs = c(
    'cigar_table_unmasked_unfiltered',
    'cigar_table_masked_filtered',
    'cigar_table_controls_masked_filtered',
    
    'metadata_kept_samples',
    'metadata_removed_samples',
    
    'plot_precentage_of_samples_over_min_abd',
    'plot_precentage_of_samples_over_min_abd_byRun',
    'plot_precentage_of_samples_over_min_abd_byVariable1',
    
    'n_off_target_alleles',
    'off_target_stats',
    'plot_off_target_stats',
    
    'n_flanking_INDEL_alleles',
    'flanking_INDEL_stats',
    'plot_flanking_INDEL_stats',
    
    'n_SNV_in_homopolymer_alleles',
    'SNV_in_homopolymer_stats',
    'plot_SNV_in_homopolymer_stats',
    
    'n_INDEL_in_homopolymer_alleles',
    'INDEL_in_homopolymer_stats',
    'plot_INDEL_in_homopolymer_stats',
    
    'n_bimera_alleles',
    'bimera_stats',
    'plot_bimera_stats',
    
    'n_PCR_errors_alleles',
    'PCR_errors_stats',
    'plot_PCR_errors_stats',
    
    'ReadDepth_coverage',
    'ReadDepth_coverage_by_run',
    'ReadDepth_coverage_by_run_controls',
    'all_loci_amplification_rate',
    'samples_amplification_rate'
    )
  
  Performance_Report_outputs = Performance_Report_expected_outputs[Performance_Report_expected_outputs %in% ls()]
  
  imagename = file.path(wd,paste0(output, '_Performance_Report.RData'))
  
  save(file = imagename, list = Performance_Report_outputs)
  
  system(paste0('cp ', file.path(fd, 'MHap_Analysis_Performance_Report_Template.Rmd'), ' ', file.path(wd, paste0(output, '_Performance_Report.Rmd'))))
  
  # Assign variables based on command-line arguments
  render(file.path(wd, paste0(output, '_Performance_Report.Rmd')), params = list(
    RData_image = imagename),
    output_dir = wd)
  
  print("Leaving render script")
  
}


# if data was imported as cigar tables and no additional steps were provided
if((!is.null(cigar_paths)|!is.null(cigar_files)) & 
   # is.null(ibd_thres) & 
   # Drug_Surveillance_Report == FALSE & 
   # is.null(poly_formula) &
   # Variants_of_Interest_Report == FALSE &
   !is.null(ampseq_export_format)){
  
  if(ampseq_export_format == 'excel'){
    
    print('exporting ampseq object as an excel file')
    write_ampseq(ampseq_object = ampseq_object,
                 format = ampseq_export_format,
                 name = file.path(wd, paste0(output, '.xlsx')))
    
  }else if(ampseq_export_format == 'csv'){
    print('exporting ampseq object as several csv files')
    write_ampseq(ampseq_object = ampseq_object,
                 format = ampseq_export_format,
                 name = file.path(wd, paste0(output, '_csv')))
    
  }else if(ampseq_export_format == 'json'){
    print('exporting ampseq object as a json file')
    write_ampseq(ampseq_object = ampseq_object,
                 format = ampseq_export_format,
                 name = file.path(wd, paste0(output, '.json')))
    
  }

}


# Drug Resistance surveillance ----

if(Drug_Surveillance_Report){
  
  print('Starting drug surveillance report')
  
  variables = 'Sample_id'
  
  if(!is.null(Variable1)){
    variables = c(variables, Variable1)
  }
  
  if(!is.null(Variable2)){
    variables = c(variables, Variable2)
  }
  
  
  if(include_all_drug_markers){
    
    print('including drug markers with low amplification rate')
    ampseq_drug = ampseq_object
    
    ampseq_drug@gt = cbind(ampseq_drug@gt,
                           ampseq_drug@discarded_loci$gt[rownames(ampseq_drug@discarded_loci$gt) %in%
                                                           rownames(ampseq_drug@gt),
                                                         grepl(paste0(gene_names, collapse = '|'),colnames(ampseq_drug@discarded_loci$gt))]
    )
    
    ampseq_drug@markers = rbind(ampseq_drug@markers,
                                ampseq_drug@discarded_loci$markers[grepl(paste0(gene_names, collapse = '|'),ampseq_drug@discarded_loci$markers$amplicon),])
    
  }else{
    
    ampseq_drug = ampseq_object
    
  }
  
  
  drug_resistant_haplotypes_plot = drug_resistant_haplotypes(ampseq_object = ampseq_drug,
                                                             reference_alleles = reference_alleles,
                                                             gene_names = gene_names,
                                                             gene_ids = gene_ids,
                                                             gff_file = ref_gff,
                                                             fasta_file = ref_fasta,
                                                             variables = variables,
                                                             Longitude = Longitude,
                                                             Latitude = Latitude,
                                                             na.var.rm = na_var_rm,
                                                             na.hap.rm = na_hap_rm,
                                                             drugs = drugs,
                                                             filters = NULL,
                                                             hap_color_palette = hap_color_palette)
  
  print('Generation of plots and tables for DRS report done')
  
  imagename = file.path(wd,paste0(output, '_DRS_Report.RData'))
  
  save(file = imagename, list = c('drug_resistant_haplotypes_plot', 'Longitude', 'Latitude'))
  
  # Full report
  
  system(paste0('cp ', file.path(fd, 'MHap_Analysis_DRS_Report_Template.Rmd'), ' ', file.path(wd, paste0(output, '_DRS_Report.Rmd'))))
  
  # Assign variables based on command-line arguments
  render(file.path(wd, paste0(output, '_DRS_Report.Rmd')), params = list(
    RData_image = imagename),
  output_dir = wd)

  # Minimal report
  
  system(paste0('cp ', file.path(fd, 'MHap_Analysis_DRS_Minimal_Report_Template.Rmd'), ' ', file.path(wd, paste0(output, '_DRS_Minimal_Report.Rmd'))))
  # Assign variables based on command-line arguments
  render(file.path(wd, paste0(output, '_DRS_Minimal_Report.Rmd')), params = list(
    RData_image = imagename),
    output_dir = wd)
  
  print("Leaving render script")
  
}

# Variants of interest ----

if(Variants_of_Interest_Report){
  
  variables = 'Sample_id'
  
  if(!is.null(Variable1)){
    variables = c(variables, Variable1)
  }
  
  if(!is.null(Variable2)){
    variables = c(variables, Variable2)
  }
  
  haplotypes_respect_to_reference_plot = haplotypes_respect_to_reference(ampseq_object,
                                                             gene_names = gene_names,
                                                             gene_ids = gene_ids,
                                                             gff_file = ref_gff,
                                                             fasta_file = ref_fasta,
                                                             variables = variables,
                                                             plot_haplo_freq = TRUE,
                                                             na.var.rm = na_var_rm,
                                                             filters = NULL)
  
  imagename = file.path(wd,paste0(output, '_VoI_Report.RData'))
  
  save(file = imagename, list = c('haplotypes_respect_to_reference_plot'))
  
}


# Genetic Variants of interest---

# Genetic Relatedness ----

if(!is.null(ibd_thres)){
  
  # call hmmIBD and PCA functions from Rcpp
  sourceCpp(file.path(fd,'hmmloglikelihood.cpp'))
  
  if(nTasks > 1 & !is.null(nTasks)){
    
    if(ibd_step == 'pairwise'){
      
      if(!file.exists(file.path(wd, 'pairwise_ibd_chunks'))){
        system(paste0('mkdir ', file.path(wd, 'pairwise_ibd_chunks')))
      }
      
      chunks = round(seq(1, nChunks + 1, length.out = nTasks + 1))
      low = chunks[Task_id]
      high = chunks[Task_id + 1] - 1
      
      pairwise_relatedness = NULL
      
      for(w in low:high){
        start = Sys.time()
        pairwise_relatedness = rbind(pairwise_relatedness,
                                     pairwise_hmmIBD(ampseq_object, parallel = parallel, w = w, n = nChunks))
        time_diff = Sys.time() - start
        
        print(paste0('step ', w, ' done in ', time_diff, ' secs'))
        
      }
      
      write.csv(pairwise_relatedness,
                file.path(wd, 'pairwise_ibd_chunks', paste0('pairwise_ibd_chunk_', Task_id, '.csv')),
                quote = FALSE,
                row.names = FALSE)
      
    }else if(ibd_step == 'merge'){
      
      pairwise_relatedness = NULL
      
      for(file in list.files(file.path(wd, 'pairwise_ibd_chunks'))){
        
        pairwise_relatedness = rbind(pairwise_relatedness,
                                     read.csv(file.path(wd, 'pairwise_ibd_chunks', file)))
        
      }
      
      write.csv(pairwise_relatedness,
                file.path(wd, paste0(output, '_pairwise_ibd', '.csv')),
                quote = FALSE,
                row.names = FALSE)
      
      ## Genetic connectivity----
      
      plot_relatedness_distribution_between = plot_relatedness_distribution(
        pairwise_relatedness = pairwise_relatedness,
        metadata = ampseq_object@metadata,
        Population = Variable1,
        fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))*(length(unique(ampseq_object@metadata[[Variable1]]))-1)/2),
        type_pop_comparison = 'between',
        ncol = 3,
        pop_levels = NULL
      )
      
      
      plot_frac_highly_related_between = plot_frac_highly_related(
        pairwise_relatedness = pairwise_relatedness,
        metadata = ampseq_object@metadata,
        Population = Variable1,
        fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))*(length(unique(ampseq_object@metadata[[Variable1]]))-1)/2),
        threshold = ibd_thres,
        type_pop_comparison = 'between',
        pop_levels = NULL)
      
      
      if(!is.null(Variable2)){
        plot_frac_highly_related_overtime_between = plot_frac_highly_related_over_time(
          pairwise_relatedness = pairwise_relatedness,
          metadata = ampseq_object@metadata,
          Population = c(Variable1, Variable2),
          fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))*(length(unique(ampseq_object@metadata[[Variable1]]))-1)/2),
          threshold = ibd_thres,
          type_pop_comparison = 'between',
          ncol = 3,
          pop_levels = NULL)
      }
      
      
      ## Population subdivision----
      
      evectors_IBD = IBD_evectors(ampseq_object = ampseq_object,
                                  relatedness_table = pairwise_relatedness,
                                  k = length(unique(ampseq_object@metadata$Sample_id)),
                                  Pop = Variable1, q = 2)
      
      names(evectors_IBD$eigenvector)[3] = 'Variable1'
      
      # Define seed for the assignment of colors
      set.seed(1)
      
      IBD_PCA = evectors_IBD$eigenvector %>% ggplot(aes(x = PC1, y = PC2, color = Variable1))+
        geom_point(alpha = .7, size = 2) +
        stat_ellipse(level = .6)+
        scale_color_manual(values = sample(col_vector, nlevels(as.factor(ampseq_object@metadata[[Variable1]]))))+
        theme_bw()+
        labs(x = paste0('1st PCo (', round(evectors_IBD$contrib[1],1), '%)'),
             y = paste0('2nd PCo (', round(evectors_IBD$contrib[2],1), '%)'),
             color = 'Countries')
      
      
      
      print('Generation of plots and tables for IBD and Connectivity report done')
      
      imagename = file.path(wd,paste0(output, '_IBD_Connectivity_Report.RData'))
      
      IBD_Connectivity_Report_expected_outputs = c('plot_relatedness_distribution_between',
                                                   'plot_frac_highly_related_between',
                                                   'plot_frac_highly_related_overtime_between',
                                                   'evectors_IBD',
                                                   'IBD_PCA',
                                                   'pairwise_relatedness',
                                                   'ibd_thres',
                                                   'ampseq_object',
                                                   'plot_network',
                                                   'create_ampseq',
                                                   'Variable1',
                                                   'Variable2')
      
      IBD_Connectivity_Report_outputs = IBD_Connectivity_Report_expected_outputs[IBD_Connectivity_Report_expected_outputs %in% ls()]
      
      save(file = imagename, list = IBD_Connectivity_Report_outputs)
      
      system(paste0('cp ', file.path(fd, 'MHap_Analysis_IBD_Connectivity_Report_Template.Rmd'), ' ', file.path(wd, paste0(output, '_IBD_Connectivity_Report.Rmd'))))
      
      # Assign variables based on command-line arguments
      render(file.path(wd, paste0(output, '_IBD_Connectivity_Report.Rmd')), params = list(
        RData_image = imagename),
        output_dir = wd)
      
      print("Leaving render script")
      
      
      ## Relatedness and transmission----
      
      plot_relatedness_distribution_within = plot_relatedness_distribution(
        pairwise_relatedness = pairwise_relatedness,
        metadata = ampseq_object@metadata,
        Population = Variable1,
        fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))),
        type_pop_comparison = 'within',
        ncol = 3,
        pop_levels = NULL
      )
      
      
      plot_frac_highly_related_within = plot_frac_highly_related(
        pairwise_relatedness = pairwise_relatedness,
        metadata = ampseq_object@metadata,
        Population = Variable1,
        fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))),
        threshold = ibd_thres,
        type_pop_comparison = 'within',
        pop_levels = NULL)
      
      
      if(!is.null(Variable2)){
        plot_frac_highly_related_overtime_within = plot_frac_highly_related_over_time(
          pairwise_relatedness = pairwise_relatedness,
          metadata = ampseq_object@metadata,
          Population = c(Variable1, Variable2),
          fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))),
          threshold = ibd_thres,
          type_pop_comparison = 'within',
          ncol = 3,
          pop_levels = NULL)
      }
      
      print('Generation of plots and tables for IBD and Transmission report done')
      
      imagename = file.path(wd,paste0(output, '_IBD_Transmission_Report.RData'))
      
      IBD_Transmission_Report_expected_outputs = c('plot_relatedness_distribution_within',
                                                   'plot_frac_highly_related_within',
                                                   'plot_frac_highly_related_overtime_within',
                                                   'Variable2')
      
      IBD_Transmission_Report_outputs = IBD_Transmission_Report_expected_outputs[IBD_Transmission_Report_expected_outputs %in% ls()]
      
      save(file = imagename, list = IBD_Transmission_Report_outputs)
      
      system(paste0('cp ', file.path(fd, 'MHap_Analysis_IBD_Transmission_Report_Template.Rmd'), ' ', file.path(wd, paste0(output, '_IBD_Transmission_Report.Rmd'))))
      
      # Assign variables based on command-line arguments
      render(file.path(wd, paste0(output, '_IBD_Transmission_Report.Rmd')), params = list(
        RData_image = imagename),
        output_dir = wd)
      
      print("Leaving render script")
      
      
    }
    
  }else if(nTasks == 1 | is.null(nTasks)){
    
    if(is.null(pairwise_relatedness_table)){
      pairwise_relatedness = NULL
      
      for(w in nChunks){
        start = Sys.time()
        pairwise_relatedness = rbind(pairwise_relatedness,
                                     pairwise_hmmIBD(ampseq_object, parallel = parallel, w = w, n = nChunks))
        time_diff = Sys.time() - start
        
        print(paste0('step ', w, ' done in ', time_diff, ' secs'))
        
      }
      
      write.csv(pairwise_relatedness,
                file.path(wd, paste0(output, '_pairwise_ibd', '.csv')),
                quote = FALSE,
                row.names = FALSE)
      
    }else{
      
      pairwise_relatedness = read.csv(pairwise_relatedness_table)
      
    }
    
    
    ## Genetic connectivity----
    
    plot_relatedness_distribution_between = plot_relatedness_distribution(
      pairwise_relatedness = pairwise_relatedness,
      metadata = ampseq_object@metadata,
      Population = Variable1,
      fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))*(length(unique(ampseq_object@metadata[[Variable1]]))-1)/2),
      type_pop_comparison = 'between',
      ncol = 3,
      pop_levels = NULL
    )
    
    
    plot_frac_highly_related_between = plot_frac_highly_related(
      pairwise_relatedness = pairwise_relatedness,
      metadata = ampseq_object@metadata,
      Population = Variable1,
      fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))*(length(unique(ampseq_object@metadata[[Variable1]]))-1)/2),
      threshold = ibd_thres,
      type_pop_comparison = 'between',
      pop_levels = NULL)
    
    
    if(!is.null(Variable2)){
      plot_frac_highly_related_overtime_between = plot_frac_highly_related_over_time(
        pairwise_relatedness = pairwise_relatedness,
        metadata = ampseq_object@metadata,
        Population = c(Variable1, Variable2),
        fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))*(length(unique(ampseq_object@metadata[[Variable1]]))-1)/2),
        threshold = ibd_thres,
        type_pop_comparison = 'between',
        ncol = 3,
        pop_levels = NULL)
    }
    
    
    ## Population subdivision----
    
    evectors_IBD = IBD_evectors(ampseq_object = ampseq_object,
                                relatedness_table = pairwise_relatedness,
                                k = length(unique(ampseq_object@metadata$Sample_id)),
                                Pop = Variable1, q = 2)
    
    names(evectors_IBD$eigenvector)[3] = 'Variable1'
    
    set.seed(1)

    IBD_PCA = evectors_IBD$eigenvector %>% ggplot(aes(x = PC1, y = PC2, color = Variable1))+
      geom_point(alpha = .7, size = 2) +
      stat_ellipse(level = .6)+
      scale_color_manual(values = sample(col_vector, nlevels(as.factor(ampseq_object@metadata[[Variable1]]))))+
      theme_bw()+
      labs(x = paste0('1st PCo (', round(evectors_IBD$contrib[1],1), '%)'),
           y = paste0('2nd PCo (', round(evectors_IBD$contrib[2],1), '%)'),
           color = 'Countries')
    
    
    
    print('Generation of plots and tables for IBD and Connectivity report done')
    
    imagename = file.path(wd,paste0(output, '_IBD_Connectivity_Report.RData'))
    
    IBD_Connectivity_Report_expected_outputs = c('plot_relatedness_distribution_between',
                                                 'plot_frac_highly_related_between',
                                                 'plot_frac_highly_related_overtime_between',
                                                 'evectors_IBD',
                                                 'IBD_PCA',
                                                 'pairwise_relatedness',
                                                 'ibd_thres',
                                                 'ampseq_object',
                                                 'plot_network',
                                                 'create_ampseq',
                                                 'Variable1',
                                                 'Variable2')
    
    IBD_Connectivity_Report_outputs = IBD_Connectivity_Report_expected_outputs[IBD_Connectivity_Report_expected_outputs %in% ls()]
    
    save(file = imagename, list = IBD_Connectivity_Report_outputs)
    
    system(paste0('cp ', file.path(fd, 'MHap_Analysis_IBD_Connectivity_Report_Template.Rmd'), ' ', file.path(wd, paste0(output, '_IBD_Connectivity_Report.Rmd'))))
    
    # Assign variables based on command-line arguments
    render(file.path(wd, paste0(output, '_IBD_Connectivity_Report.Rmd')), params = list(
      RData_image = imagename),
      output_dir = wd)
    
    print("Leaving render script")
    
    
    ## Relatedness and transmission----
    
    plot_relatedness_distribution_within = plot_relatedness_distribution(
      pairwise_relatedness = pairwise_relatedness,
      metadata = ampseq_object@metadata,
      Population = Variable1,
      fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))),
      type_pop_comparison = 'within',
      ncol = 3,
      pop_levels = NULL
    )
    
    
    plot_frac_highly_related_within = plot_frac_highly_related(
      pairwise_relatedness = pairwise_relatedness,
      metadata = ampseq_object@metadata,
      Population = Variable1,
      fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))),
      threshold = ibd_thres,
      type_pop_comparison = 'within',
      pop_levels = NULL)
    
    
    if(!is.null(Variable2)){
      plot_frac_highly_related_overtime_within = plot_frac_highly_related_over_time(
        pairwise_relatedness = pairwise_relatedness,
        metadata = ampseq_object@metadata,
        Population = c(Variable1, Variable2),
        fill_color = rep('gray50', length(unique(ampseq_object@metadata[[Variable1]]))),
        threshold = ibd_thres,
        type_pop_comparison = 'within',
        ncol = 3,
        pop_levels = NULL)
    }
    
    print('Generation of plots and tables for IBD and Transmission report done')
    
    imagename = file.path(wd,paste0(output, '_IBD_Transmission_Report.RData'))
    
    IBD_Transmission_Report_expected_outputs = c('plot_relatedness_distribution_within',
                                                 'plot_frac_highly_related_within',
                                                 'plot_frac_highly_related_overtime_within',
                                                 'Variable2')
    
    IBD_Transmission_Report_outputs = IBD_Transmission_Report_expected_outputs[IBD_Transmission_Report_expected_outputs %in% ls()]
    
    save(file = imagename, list = IBD_Transmission_Report_outputs)
    
    system(paste0('cp ', file.path(fd, 'MHap_Analysis_IBD_Transmission_Report_Template.Rmd'), ' ', file.path(wd, paste0(output, '_IBD_Transmission_Report.Rmd'))))
    
    # Assign variables based on command-line arguments
    render(file.path(wd, paste0(output, '_IBD_Transmission_Report.Rmd')), params = list(
      RData_image = imagename),
      output_dir = wd)
    
    print("Leaving render script")
    
  }
}


# COI----

if(!is.null(poly_formula)){
  
  print('Starting COI report')
  
  if(is.null(poly_quantile)){
    poly_quantile = 0.75
  }
  
  if(!is.null(Variable1)){
    
    print('Calculate COI metrics by Variable1')
    
    poly_by_Var1 = get_polygenomic(ampseq_object = ampseq_object, 
                                   strata = Variable1,
                                   update_popsummary = FALSE,
                                   na.rm = na_var_rm,
                                   filters = NULL,
                                   poly_quantile = poly_quantile,
                                   poly_formula = poly_formula)
    
    set.seed(1)
    
    plot_poly_by_pop = poly_by_Var1$pop_summary %>% 
      ggplot(aes(x = factor(pop, 
                            levels = c(unique(poly_by_Var1$pop_summary$pop)[unique(poly_by_Var1$pop_summary$pop) != 'Total'], "Total")),
                 y = prop_poly,
                 fill = factor(pop, 
                               levels = c(unique(poly_by_Var1$pop_summary$pop)[unique(poly_by_Var1$pop_summary$pop) != 'Total'], "Total"))))+
      geom_col(alpha = .6) +
      geom_errorbar(aes(ymin = prop_poly_lower, ymax = prop_poly_upper), width = .2)+
      theme_bw() +
      labs(title = "Frequency of polyclonal infections",
           y = "Frecquency") +
      scale_fill_manual(values = c(sample(col_vector, nlevels(as.factor(ampseq_object@metadata[[Variable1]]))), "gray30"))+
      theme(axis.text = element_text(size = 12),
            axis.title = element_blank(),
            legend.position = "none",
            axis.text.x = element_text(angle = 90, vjust = 0.5))
    
  }else{
    
    print('Calculate COI metrics by the overall population')
    
    poly_total = get_polygenomic(ampseq_object = ampseq_object, 
                                 strata = NULL,
                                 update_popsummary = FALSE,
                                 na.rm = na_var_rm,
                                 filters = NULL,
                                 poly_quantile = poly_quantile,
                                 poly_formula = poly_formula)
    
  }
  
  
  
  if(!is.null(Variable1) & !is.null(Variable2)){
    
    print('Calculate COI metrics by Variable1 and Varibale2')
    
    ampseq_object@metadata[['Var1_Var2']] = paste(ampseq_object@metadata[[Variable1]], ampseq_object@metadata[[Variable2]], sep = '::')
    
    poly_by_Var1_Var2 = get_polygenomic(ampseq_object = ampseq_object,
                                        strata = "Var1_Var2",
                                        update_popsummary = F,
                                        na.rm = TRUE,
                                        filters = NULL,
                                        poly_quantile = poly_quantile, 
                                        poly_formula = poly_formula
                                        )
    
    set.seed(1)
    
    plot_poly_by_Var1_Var2 = poly_by_Var1_Var2$pop_summary %>%
      filter(pop != 'Total')%>%
      mutate(
        Variable1 = stringr::str_split(pop, '::', simplify = TRUE)[,1],
        Variable2 = stringr::str_split(pop, '::', simplify = TRUE)[,2],
        prop_poly_lower = case_when(
          prop_poly == 0 ~ 0,
          prop_poly != 0 ~ prop_poly_lower),
        prop_poly_upper = case_when(
          prop_poly == 0 ~ 0,
          prop_poly != 0 ~ prop_poly_upper)
      )%>%
      ggplot(aes(x = Variable2,
                 y = prop_poly,
                 ymin = prop_poly_lower,
                 ymax = prop_poly_upper,
                 fill = Variable1))+
      geom_col()+
      geom_errorbar(width = .2)+
      facet_wrap(~Variable1, ncol = 3)+
      theme_bw()+
      scale_fill_manual(values = sample(col_vector, nlevels(as.factor(ampseq_object@metadata[[Variable1]]))))+
      labs(title = 'Temporal change of the proportion of polyclonal infections',
           y = "Polyclonal infections",
           x = Variable2)+
      theme(axis.text.x = element_text(angle = 90, vjust = 0.5),
            legend.position =  "none")
    
  }
  

  print('Generation of plots and tables for COI report done')
  
  imagename = file.path(wd,paste0(output, '_COI_Report.RData'))
  
  COI_Report_expected_outputs = c('poly_total',
                                  'poly_by_Var1',
                                  'plot_poly_by_pop',
                                  'poly_by_Var1_Var2',
                                  'plot_poly_by_Var1_Var2',
                                  'Variable1',
                                  'Variable2')
  
  COI_Report_outputs = COI_Report_expected_outputs[COI_Report_expected_outputs %in% ls()]
  
  save(file = imagename, list = COI_Report_outputs)
  
  system(paste0('cp ', file.path(fd, 'MHap_Analysis_COI_Report_Template.Rmd'), ' ', file.path(wd, paste0(output, '_COI_Report.Rmd'))))
  
  # Assign variables based on command-line arguments
  render(file.path(wd, paste0(output, '_COI_Report.Rmd')), params = list(
    RData_image = imagename),
    output_dir = wd)
  
  print("Leaving render script")
  
}



# Genetic diversity----


